/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Specifies the format of the BOM. This helps to identify the file as CycloneDX since BOMs do not have a filename convention, nor does JSON schema support namespaces. This value must be "CycloneDX".
 */
export type BOMFormat = "CycloneDX";
/**
 * The version of the CycloneDX specification the BOM conforms to.
 */
export type CycloneDXSpecificationVersion = string;
/**
 * Every BOM generated SHOULD have a unique serial number, even if the contents of the BOM have not changed over time. If specified, the serial number must conform to [RFC 4122](https://www.ietf.org/rfc/rfc4122.html). Use of serial numbers is recommended.
 */
export type BOMSerialNumber = string;
/**
 * Whenever an existing BOM is modified, either manually or through automated processes, the version of the BOM SHOULD be incremented by 1. When a system is presented with multiple BOMs with identical serial numbers, the system SHOULD use the most recent version of the BOM. The default version is '1'.
 */
export type BOMVersion = number;
/**
 * The date and time (timestamp) when the BOM was created.
 */
export type Timestamp = string;
/**
 * The product lifecycle(s) that this BOM represents.
 */
export type Lifecycle = PreDefinedPhase | CustomPhase;
/**
 * A pre-defined phase in the product lifecycle.
 */
export type Phase = "design" | "pre-build" | "build" | "post-build" | "operations" | "discovery" | "decommission";
/**
 * The name of the lifecycle phase
 */
export type Name = string;
/**
 * The description of the lifecycle phase
 */
export type Description = string;
/**
 * Lifecycles communicate the stage(s) in which data in the BOM was captured. Different types of data may be available at various phases of a lifecycle, such as the Software Development Lifecycle (SDLC), IT Asset Management (ITAM), and Software Asset Management (SAM). Thus, a BOM may include data specific to or only obtainable in a given lifecycle.
 */
export type Lifecycles = Lifecycle[];
/**
 * The tool(s) used in the creation, enrichment, and validation of the BOM.
 */
export type Tools = Tools1 | ToolsLegacy;
/**
 * Specifies the type of component. For software components, classify as application if no more specific appropriate classification is available or cannot be determined for the component.
 */
export type ComponentType =
  | "application"
  | "framework"
  | "library"
  | "container"
  | "platform"
  | "operating-system"
  | "device"
  | "device-driver"
  | "firmware"
  | "file"
  | "machine-learning-model"
  | "data"
  | "cryptographic-asset";
/**
 * The optional mime-type of the component. When used on file components, the mime-type can provide additional context about the kind of file being represented, such as an image, font, or executable. Some library or framework components may also have an associated mime-type.
 */
export type MimeType = string;
/**
 * An optional identifier which can be used to reference the component elsewhere in the BOM. Every bom-ref must be unique within the BOM.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference = string;
/**
 * An optional identifier which can be used to reference the object elsewhere in the BOM. Every bom-ref must be unique within the BOM.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference1 = string;
/**
 * The name of the organization
 */
export type OrganizationName = string;
/**
 * An optional identifier which can be used to reference the address elsewhere in the BOM. Every bom-ref must be unique within the BOM.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference2 = string;
/**
 * The country name or the two-letter ISO 3166-1 country code.
 */
export type Country = string;
/**
 * The region or state in the country.
 */
export type Region = string;
/**
 * The locality or city within the country.
 */
export type Locality = string;
/**
 * The post office box number.
 */
export type PostOfficeBoxNumber = string;
/**
 * The postal code.
 */
export type PostalCode = string;
/**
 * The street address.
 */
export type StreetAddress = string;
/**
 * The URL of the organization. Multiple URLs are allowed.
 */
export type OrganizationURLS = string[];
/**
 * An optional identifier which can be used to reference the object elsewhere in the BOM. Every bom-ref must be unique within the BOM.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference3 = string;
/**
 * The name of a contact
 */
export type Name1 = string;
/**
 * The email address of the contact.
 */
export type EmailAddress = string;
/**
 * The phone number of the contact.
 */
export type Phone = string;
/**
 * A contact at the organization. Multiple contacts are allowed.
 */
export type OrganizationalContact = OrganizationalContact1[];
/**
 * The person(s) who created the component.
 * Authors are common in components created through manual processes. Components created through automated means may have `@.manufacturer` instead.
 */
export type ComponentAuthors = OrganizationalContact1[];
/**
 * [Deprecated] This will be removed in a future version. Use `@.authors` or `@.manufacturer` instead.
 * The person(s) or organization(s) that authored the component
 */
export type ComponentAuthorLegacy = string;
/**
 * The person(s) or organization(s) that published the component
 */
export type ComponentPublisher = string;
/**
 * The grouping name or identifier. This will often be a shortened, single name of the company or project that produced the component, or the source package or domain name. Whitespace and special characters should be avoided. Examples include: apache, org.apache.commons, and apache.org.
 */
export type ComponentGroup = string;
/**
 * The name of the component. This will often be a shortened, single name of the component. Examples: commons-lang3 and jquery
 */
export type ComponentName = string;
/**
 * The component version. The version should ideally comply with semantic versioning but is not enforced.
 */
export type ComponentVersion = string;
/**
 * Specifies a description for the component
 */
export type ComponentDescription = string;
/**
 * Specifies the scope of the component. If scope is not specified, 'required' scope SHOULD be assumed by the consumer of the BOM.
 */
export type ComponentScope = "required" | "optional" | "excluded";
/**
 * The algorithm that generated the hash value.
 */
export type HashAlgorithm =
  | "MD5"
  | "SHA-1"
  | "SHA-256"
  | "SHA-384"
  | "SHA-512"
  | "SHA3-256"
  | "SHA3-384"
  | "SHA3-512"
  | "BLAKE2b-256"
  | "BLAKE2b-384"
  | "BLAKE2b-512"
  | "BLAKE3";
/**
 * The value of the hash.
 */
export type HashValue = string;
/**
 * The hashes of the component.
 */
export type ComponentHashes = Hash[];
/**
 * EITHER (list of SPDX licenses and/or named licenses) OR (tuple of one SPDX License Expression)
 */
export type ComponentLicenseS = (MultipleLicenses | SPDXLicenseExpression) & unknown[];
/**
 * Specifies the details and attributes related to a software license. It can either include a valid SPDX license identifier or a named license, along with additional properties such as license acknowledgment, comprehensive commercial licensing information, and the full text of the license.
 */
export type License1 = {
  [k: string]: unknown;
};
/**
 * A list of SPDX licenses and/or named licenses.
 */
export type MultipleLicenses = License[];
/**
 * A tuple of exactly one SPDX License Expression.
 *
 * @minItems 1
 * @maxItems 1
 */
export type SPDXLicenseExpression = [
  {
    expression: SPDXLicenseExpression1;
    acknowledgement?: LicenseAcknowledgement;
    "bom-ref"?: BOMReference4;
  }
];
/**
 * A valid SPDX license expression.
 * Refer to https://spdx.org/specifications for syntax requirements
 */
export type SPDXLicenseExpression1 = string;
/**
 * Declared licenses and concluded licenses represent two different stages in the licensing process within software development. Declared licenses refer to the initial intention of the software authors regarding the licensing terms under which their code is released. On the other hand, concluded licenses are the result of a comprehensive analysis of the project's codebase to identify and confirm the actual licenses of the components used, which may differ from the initially declared licenses. While declared licenses provide an upfront indication of the licensing intentions, concluded licenses offer a more thorough understanding of the actual licensing within a project, facilitating proper compliance and risk management. Observed licenses are defined in `@.evidence.licenses`. Observed licenses form the evidence necessary to substantiate a concluded license.
 */
export type LicenseAcknowledgement = "declared" | "concluded";
/**
 * An optional identifier which can be used to reference the license elsewhere in the BOM. Every bom-ref must be unique within the BOM.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference4 = string;
/**
 * A copyright notice informing users of the underlying claims to copyright ownership in a published work.
 */
export type ComponentCopyright = string;
/**
 * Asserts the identity of the component using CPE. The CPE must conform to the CPE 2.2 or 2.3 specification. See [https://nvd.nist.gov/products/cpe](https://nvd.nist.gov/products/cpe). Refer to `@.evidence.identity` to optionally provide evidence that substantiates the assertion of the component's identity.
 */
export type CommonPlatformEnumerationCPE = string;
/**
 * Asserts the identity of the component using package-url (purl). The purl, if specified, must be valid and conform to the specification defined at: [https://github.com/package-url/purl-spec](https://github.com/package-url/purl-spec). Refer to `@.evidence.identity` to optionally provide evidence that substantiates the assertion of the component's identity.
 */
export type PackageURLPurl = string;
/**
 * Asserts the identity of the component using the OmniBOR Artifact ID. The OmniBOR, if specified, must be valid and conform to the specification defined at: [https://www.iana.org/assignments/uri-schemes/prov/gitoid](https://www.iana.org/assignments/uri-schemes/prov/gitoid). Refer to `@.evidence.identity` to optionally provide evidence that substantiates the assertion of the component's identity.
 */
export type OmniBORArtifactIdentifierGitoid = string[];
/**
 * Asserts the identity of the component using the Software Heritage persistent identifier (SWHID). The SWHID, if specified, must be valid and conform to the specification defined at: [https://docs.softwareheritage.org/devel/swh-model/persistent-identifiers.html](https://docs.softwareheritage.org/devel/swh-model/persistent-identifiers.html). Refer to `@.evidence.identity` to optionally provide evidence that substantiates the assertion of the component's identity.
 */
export type SoftwareHeritageIdentifier = string[];
/**
 * Maps to the tagId of a SoftwareIdentity.
 */
export type TagID = string;
/**
 * Maps to the name of a SoftwareIdentity.
 */
export type Name2 = string;
/**
 * Maps to the version of a SoftwareIdentity.
 */
export type Version = string;
/**
 * Maps to the tagVersion of a SoftwareIdentity.
 */
export type TagVersion = number;
/**
 * Maps to the patch of a SoftwareIdentity.
 */
export type Patch = boolean;
/**
 * Specifies the format and nature of the data being attached, helping systems correctly interpret and process the content. Common content type examples include `application/json` for JSON data and `text/plain` for plan text documents.
 *  [RFC 2045 section 5.1](https://www.ietf.org/rfc/rfc2045.html#section-5.1) outlines the structure and use of content types. For a comprehensive list of registered content types, refer to the [IANA media types registry](https://www.iana.org/assignments/media-types/media-types.xhtml).
 */
export type ContentType = string;
/**
 * Specifies the optional encoding the text is represented in.
 */
export type Encoding = "base64";
/**
 * The attachment data. Proactive controls such as input validation and sanitization should be employed to prevent misuse of attachment text.
 */
export type AttachmentText1 = string;
/**
 * The URL to the SWID file.
 */
export type URL = string;
/**
 * [Deprecated] This will be removed in a future version. Use the pedigree element instead to supply information on exactly how the component was modified. A boolean value indicating if the component has been modified from the original. A value of true indicates the component is a derivative of the original. A value of false indicates the component has not been modified from the original.
 */
export type ComponentModifiedFromOriginal = boolean;
/**
 * Describes zero or more components in which a component is derived from. This is commonly used to describe forks from existing projects where the forked version contains a ancestor node containing the original component it was forked from. For example, Component A is the original component. Component B is the component being used and documented in the BOM. However, Component B contains a pedigree node with a single ancestor documenting Component A - the original component from which Component B is derived from.
 */
export type Ancestors = Component[];
/**
 * Descendants are the exact opposite of ancestors. This provides a way to document all forks (and their forks) of an original or root component.
 */
export type Descendants = Component[];
/**
 * Variants describe relations where the relationship between the components is not known. For example, if Component A contains nearly identical code to Component B. They are both related, but it is unclear if one is derived from the other, or if they share a common ancestor.
 */
export type Variants = Component[];
/**
 * A unique identifier of the commit. This may be version control specific. For example, Subversion uses revision numbers whereas git uses commit hashes.
 */
export type UID = string;
/**
 * The URL to the commit. This URL will typically point to a commit in a version control system.
 */
export type URL1 = string;
/**
 * The timestamp in which the action occurred
 */
export type Timestamp1 = string;
/**
 * The name of the individual who performed the action
 */
export type Name3 = string;
/**
 * The email address of the individual who performed the action
 */
export type EMail = string;
/**
 * The text description of the contents of the commit
 */
export type Message = string;
/**
 * A list of zero or more commits which provide a trail describing how the component deviates from an ancestor, descendant, or variant.
 */
export type Commits = Commit[];
/**
 * Specifies the purpose for the patch including the resolution of defects, security issues, or new behavior or functionality.
 */
export type PatchType = "unofficial" | "monkey" | "backport" | "cherry-pick";
/**
 * Specifies the URL to the diff
 */
export type URL2 = string;
/**
 * Specifies the type of issue
 */
export type IssueType = "defect" | "enhancement" | "security";
/**
 * The identifier of the issue assigned by the source of the issue
 */
export type IssueID = string;
/**
 * The name of the issue
 */
export type IssueName = string;
/**
 * A description of the issue
 */
export type IssueDescription = string;
/**
 * The name of the source.
 */
export type Name4 = string;
/**
 * The url of the issue documentation as provided by the source
 */
export type URL3 = string;
/**
 * A collection of URL's for reference. Multiple URLs are allowed.
 */
export type References = string[];
/**
 * A collection of issues the patch resolves
 */
export type Resolves = Issue[];
/**
 * >A list of zero or more patches describing how the component deviates from an ancestor, descendant, or variant. Patches may be complementary to commits or may be used in place of commits.
 */
export type Patches = Patch1[];
/**
 * Notes, observations, and other non-structured commentary describing the components pedigree.
 */
export type Notes = string;
/**
 * The URI (URL or URN) to the external reference. External references are URIs and therefore can accept any URL scheme including https ([RFC-7230](https://www.ietf.org/rfc/rfc7230.txt)), mailto ([RFC-2368](https://www.ietf.org/rfc/rfc2368.txt)), tel ([RFC-3966](https://www.ietf.org/rfc/rfc3966.txt)), and dns ([RFC-4501](https://www.ietf.org/rfc/rfc4501.txt)). External references may also include formally registered URNs such as [CycloneDX BOM-Link](https://cyclonedx.org/capabilities/bomlink/) to reference CycloneDX BOMs or any object within a BOM. BOM-Link transforms applicable external references into relationships that can be expressed in a BOM or across BOMs.
 */
export type URL4 = URL5 | BOMLink;
export type URL5 = string;
export type BOMLink = BOMLinkDocument | BOMLinkElement;
/**
 * Descriptor for another BOM document. See https://cyclonedx.org/capabilities/bomlink/
 */
export type BOMLinkDocument = string;
/**
 * Descriptor for an element in a BOM document. See https://cyclonedx.org/capabilities/bomlink/
 */
export type BOMLinkElement = string;
/**
 * An optional comment describing the external reference
 */
export type Comment = string;
/**
 * Specifies the type of external reference.
 */
export type Type =
  | "vcs"
  | "issue-tracker"
  | "website"
  | "advisories"
  | "bom"
  | "mailing-list"
  | "social"
  | "chat"
  | "documentation"
  | "support"
  | "source-distribution"
  | "distribution"
  | "distribution-intake"
  | "license"
  | "build-meta"
  | "build-system"
  | "release-notes"
  | "security-contact"
  | "model-card"
  | "log"
  | "configuration"
  | "evidence"
  | "formulation"
  | "attestation"
  | "threat-model"
  | "adversary-model"
  | "risk-assessment"
  | "vulnerability-assertion"
  | "exploitability-statement"
  | "pentest-report"
  | "static-analysis-report"
  | "dynamic-analysis-report"
  | "runtime-analysis-report"
  | "component-analysis-report"
  | "maturity-report"
  | "certification-report"
  | "codified-infrastructure"
  | "quality-metrics"
  | "poam"
  | "electronic-signature"
  | "digital-signature"
  | "rfc-9116"
  | "other";
/**
 * The hashes of the external reference (if applicable).
 */
export type Hashes = Hash[];
/**
 * External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
 */
export type ExternalReferences = ExternalReference[];
/**
 * A list of software and hardware components included in the parent component. This is not a dependency tree. It provides a way to specify a hierarchical representation of component assemblies, similar to system &#8594; subsystem &#8594; parts assembly in physical supply chains.
 */
export type Components1 = Component[];
/**
 * Evidence that substantiates the identity of a component. The identity may be an object or an array of identity objects. Support for specifying identity as a single object was introduced in CycloneDX v1.5. Arrays were introduced in v1.6. It is recommended that all implementations use arrays, even if only one identity object is specified.
 */
export type IdentityEvidence = ArrayOfIdentityObjects | IdentityEvidence2;
/**
 * The identity field of the component which the evidence describes.
 */
export type Field = "group" | "name" | "version" | "purl" | "cpe" | "omniborId" | "swhid" | "swid" | "hash";
/**
 * The overall confidence of the evidence from 0 - 1, where 1 is 100% confidence.
 */
export type Confidence = number;
/**
 * The value of the field (cpe, purl, etc) that has been concluded based on the aggregate of all methods (if available).
 */
export type ConcludedValue = string;
/**
 * The technique used in this method of analysis.
 */
export type Technique =
  | "source-code-analysis"
  | "binary-analysis"
  | "manifest-analysis"
  | "ast-fingerprint"
  | "hash-comparison"
  | "instrumentation"
  | "dynamic-analysis"
  | "filename"
  | "attestation"
  | "other";
/**
 * The confidence of the evidence from 0 - 1, where 1 is 100% confidence. Confidence is specific to the technique used. Each technique of analysis can have independent confidence.
 */
export type Confidence1 = number;
/**
 * The value or contents of the evidence.
 */
export type Value = string;
/**
 * The methods used to extract and/or analyze the evidence.
 */
export type Methods = {
  technique: Technique;
  confidence: Confidence1;
  value?: Value;
}[];
/**
 * Descriptor for an element identified by the attribute 'bom-ref' in the same BOM document.
 * In contrast to `bomLinkElementType`.
 */
export type Ref = string;
/**
 * Descriptor for an element in a BOM document. See https://cyclonedx.org/capabilities/bomlink/
 */
export type BOMLinkElement1 = string;
/**
 * The object in the BOM identified by its bom-ref. This is often a component or service but may be any object type supporting bom-refs. Tools used for analysis should already be defined in the BOM, either in the metadata/tools, components, or formulation.
 */
export type BOMReferences = (Ref | BOMLinkElement1)[];
export type ArrayOfIdentityObjects = IdentityEvidence1[];
/**
 * An optional identifier which can be used to reference the occurrence elsewhere in the BOM. Every bom-ref must be unique within the BOM.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference5 = string;
/**
 * The location or path to where the component was found.
 */
export type Location = string;
/**
 * The line number where the component was found.
 */
export type LineNumber = number;
/**
 * The offset where the component was found.
 */
export type Offset = number;
/**
 * The symbol name that was found associated with the component.
 */
export type Symbol = string;
/**
 * Any additional context of the detected component (e.g. a code snippet).
 */
export type AdditionalContext = string;
/**
 * Evidence of individual instances of a component spread across multiple locations.
 */
export type Occurrences = {
  "bom-ref"?: BOMReference5;
  location: Location;
  line?: LineNumber;
  offset?: Offset;
  symbol?: Symbol;
  additionalContext?: AdditionalContext;
}[];
/**
 * A package organizes modules into namespaces, providing a unique namespace for each type it contains.
 */
export type Package = string;
/**
 * A module or class that encloses functions/methods and other code.
 */
export type Module = string;
/**
 * A block of code designed to perform a particular task.
 */
export type Function = string;
/**
 * Optional arguments that are passed to the module or function.
 */
export type Parameters = string[];
/**
 * The line number the code that is called resides on.
 */
export type Line = number;
/**
 * The column the code that is called resides.
 */
export type Column = number;
/**
 * The full path and filename of the module.
 */
export type FullFilename = string;
/**
 * Within a call stack, a frame is a discrete unit that encapsulates an execution context, including local variables, parameters, and the return address. As function calls are made, frames are pushed onto the stack, forming an array-like structure that orchestrates the flow of program execution and manages the sequence of function invocations.
 */
export type Frames = {
  package?: Package;
  module: Module;
  function?: Function;
  parameters?: Parameters;
  line?: Line;
  column?: Column;
  fullFilename?: FullFilename;
}[];
/**
 * EITHER (list of SPDX licenses and/or named licenses) OR (tuple of one SPDX License Expression)
 */
export type LicenseEvidence = (MultipleLicenses | SPDXLicenseExpression) & unknown[];
/**
 * The textual content of the copyright.
 */
export type CopyrightText = string;
/**
 * Copyright evidence captures intellectual property assertions, providing evidence of possible ownership and legal protection.
 */
export type CopyrightEvidence = Copyright[];
/**
 * The software versioning type the release note describes.
 */
export type Type1 = string;
/**
 * The title of the release.
 */
export type Title = string;
/**
 * The URL to an image that may be prominently displayed with the release note.
 */
export type FeaturedImage = string;
/**
 * The URL to an image that may be used in messaging on social media platforms.
 */
export type SocialImage = string;
/**
 * A short description of the release.
 */
export type Description1 = string;
/**
 * The date and time (timestamp) when the release note was created.
 */
export type Timestamp2 = string;
/**
 * One or more alternate names the release may be referred to. This may include unofficial terms used by development and marketing teams (e.g. code names).
 */
export type Aliases = string[];
/**
 * Textual strings that aid in discovery, search, and retrieval of the associated object. Tags often serve as a way to group or categorize similar or related objects by various attributes.
 */
export type Tags = string[];
/**
 * A collection of issues that have been resolved.
 */
export type Resolves1 = Issue[];
/**
 * The ISO-639 (or higher) language code and optional ISO-3166 (or higher) country code. Examples include: "en", "en-US", "fr" and "fr-CA"
 */
export type Locale = string;
/**
 * Zero or more release notes containing the locale and content. Multiple note objects may be specified to support release notes in a wide variety of languages.
 */
export type Notes1 = Note[];
/**
 * The name of the property. Duplicate names are allowed, each potentially having a different value.
 */
export type Name5 = string;
/**
 * The value of the property.
 */
export type Value1 = string;
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties = LightweightNameValuePair[];
/**
 * An optional identifier which can be used to reference the model card elsewhere in the BOM. Every bom-ref must be unique within the BOM.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference6 = string;
/**
 * Learning types describing the learning problem or hybrid learning problem.
 */
export type LearningType =
  | "supervised"
  | "unsupervised"
  | "reinforcement-learning"
  | "semi-supervised"
  | "self-supervised";
/**
 * Directly influences the input and/or output. Examples include classification, regression, clustering, etc.
 */
export type Task = string;
/**
 * The model architecture family such as transformer network, convolutional neural network, residual neural network, LSTM neural network, etc.
 */
export type ArchitectureFamily = string;
/**
 * The specific architecture of the model such as GPT-1, ResNet-50, YOLOv3, etc.
 */
export type ModelArchitecture = string;
/**
 * An optional identifier which can be used to reference the dataset elsewhere in the BOM. Every bom-ref must be unique within the BOM.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference7 = string;
/**
 * The general theme or subject matter of the data being specified.
 */
export type TypeOfData = "source-code" | "configuration" | "dataset" | "definition" | "other";
/**
 * The name of the dataset.
 */
export type DatasetName = string;
/**
 * The URL to where the data can be retrieved.
 */
export type DataURL = string;
/**
 * Provides the ability to document name-value parameters used for configuration.
 */
export type ConfigurationProperties = LightweightNameValuePair[];
/**
 * Data classification tags data according to its type, sensitivity, and value if altered, stolen, or destroyed.
 */
export type DataClassification = string;
/**
 * A description of any sensitive data in a dataset.
 */
export type SensitiveData = string[];
/**
 * A description of this collection of graphics.
 */
export type Description2 = string;
/**
 * The name of the graphic.
 */
export type Name6 = string;
/**
 * A collection of graphics.
 */
export type Collection = Graphic[];
/**
 * A description of the dataset. Can describe size of dataset, whether it's used for source code, training, testing, or validation, etc.
 */
export type DatasetDescription = string;
export type DataGovernanceResponsibleParty = {
  organization?: Organization;
  contact?: OrganizationalContact2;
} & DataGovernanceResponsibleParty1;
export type DataGovernanceResponsibleParty1 = {
  [k: string]: unknown;
};
/**
 * Data custodians are responsible for the safe custody, transport, and storage of data.
 */
export type DataCustodians = DataGovernanceResponsibleParty[];
/**
 * Data stewards are responsible for data content, context, and associated business rules.
 */
export type DataStewards = DataGovernanceResponsibleParty[];
/**
 * Data owners are concerned with risk and appropriate access to data.
 */
export type DataOwners = DataGovernanceResponsibleParty[];
/**
 * References a data component by the components bom-ref attribute
 */
export type Reference = (Ref1 | BOMLinkElement2) & string;
/**
 * Descriptor for an element identified by the attribute 'bom-ref' in the same BOM document.
 * In contrast to `bomLinkElementType`.
 */
export type Ref1 = string;
/**
 * Descriptor for an element in a BOM document. See https://cyclonedx.org/capabilities/bomlink/
 */
export type BOMLinkElement2 = string;
/**
 * The datasets used to train and evaluate the model.
 */
export type Datasets = (InlineDataInformation | DataReference)[];
/**
 * The data format for input/output to the model.
 */
export type InputOutputFormat = string;
/**
 * The input format(s) of the model
 */
export type Inputs = InputAndOutputParameters[];
/**
 * The output format(s) from the model
 */
export type Outputs = InputAndOutputParameters[];
/**
 * The type of performance metric.
 */
export type Type2 = string;
/**
 * The value of the performance metric.
 */
export type Value2 = string;
/**
 * The name of the slice this metric was computed on. By default, assume this metric is not sliced.
 */
export type Slice = string;
/**
 * The lower bound of the confidence interval.
 */
export type LowerBound = string;
/**
 * The upper bound of the confidence interval.
 */
export type UpperBound = string;
/**
 * The model performance metrics being reported. Examples may include accuracy, F1 score, precision, top-3 error rates, MSC, etc.
 */
export type PerformanceMetrics = PerformanceMetric[];
/**
 * Who are the intended users of the model?
 */
export type Users = string[];
/**
 * What are the intended use cases of the model?
 */
export type UseCases = string[];
/**
 * What are the known technical limitations of the model? E.g. What kind(s) of data should the model be expected not to perform well on? What are the factors that might degrade model performance?
 */
export type TechnicalLimitations = string[];
/**
 * What are the known tradeoffs in accuracy/performance of the model?
 */
export type PerformanceTradeoffs = string[];
/**
 * The name of the risk.
 */
export type Name7 = string;
/**
 * Strategy used to address this risk.
 */
export type MitigationStrategy = string;
/**
 * What are the ethical risks involved in the application of this model?
 */
export type EthicalConsiderations = Risk[];
/**
 * The type of activity that is part of a machine learning model development or operational lifecycle.
 */
export type Activity =
  | "design"
  | "data-collection"
  | "data-preparation"
  | "training"
  | "fine-tuning"
  | "validation"
  | "deployment"
  | "inference"
  | "other";
/**
 * An optional identifier which can be used to reference the energy provider elsewhere in the BOM. Every bom-ref must be unique within the BOM.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference8 = string;
/**
 * A description of the energy provider.
 */
export type Description3 = string;
/**
 * The energy source for the energy provider.
 */
export type EnergySource =
  | "coal"
  | "oil"
  | "natural-gas"
  | "nuclear"
  | "wind"
  | "solar"
  | "geothermal"
  | "hydropower"
  | "biofuel"
  | "unknown"
  | "other";
/**
 * Quantity of energy.
 */
export type Value3 = number;
/**
 * Unit of energy.
 */
export type Unit = "kWh";
/**
 * External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
 */
export type ExternalReferences1 = ExternalReference[];
/**
 * The provider(s) of the energy consumed by the associated model development lifecycle activity.
 */
export type EnergyProviders = EnergyProvider[];
/**
 * Quantity of carbon dioxide (CO2).
 */
export type Value4 = number;
/**
 * Unit of carbon dioxide (CO2).
 */
export type Unit1 = "tCO2eq";
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties1 = LightweightNameValuePair[];
/**
 * Describes energy consumption information incurred for one or more component lifecycle activities.
 */
export type EnergyConsumptions = EnergyConsumption[];
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties2 = LightweightNameValuePair[];
/**
 * The groups or individuals at risk of being systematically disadvantaged by the model.
 */
export type GroupAtRisk = string;
/**
 * Expected benefits to the identified groups.
 */
export type Benefits = string;
/**
 * Expected harms to the identified groups.
 */
export type Harms = string;
/**
 * With respect to the benefits and harms outlined, please describe any mitigation strategy implemented.
 */
export type MitigationStrategy1 = string;
/**
 * How does the model affect groups at risk of being systematically disadvantaged? What are the harms and benefits to the various affected groups?
 */
export type FairnessAssessments = FairnessAssessment[];
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties3 = LightweightNameValuePair[];
/**
 * This object SHOULD be specified for any component of type `data` and must not be specified for other component types.
 */
export type Data = ComponentData[];
/**
 * Cryptographic assets occur in several forms. Algorithms and protocols are most commonly implemented in specialized cryptographic libraries. They may, however, also be 'hardcoded' in software components. Certificates and related cryptographic material like keys, tokens, secrets or passwords are other cryptographic assets to be modelled.
 */
export type AssetType = "algorithm" | "certificate" | "protocol" | "related-crypto-material";
/**
 * Cryptographic building blocks used in higher-level cryptographic systems and protocols. Primitives represent different cryptographic routines: deterministic random bit generators (drbg, e.g. CTR_DRBG from NIST SP800-90A-r1), message authentication codes (mac, e.g. HMAC-SHA-256), blockciphers (e.g. AES), streamciphers (e.g. Salsa20), signatures (e.g. ECDSA), hash functions (e.g. SHA-256), public-key encryption schemes (pke, e.g. RSA), extended output functions (xof, e.g. SHAKE256), key derivation functions (e.g. pbkdf2), key agreement algorithms (e.g. ECDH), key encapsulation mechanisms (e.g. ML-KEM), authenticated encryption (ae, e.g. AES-GCM) and the combination of multiple algorithms (combiner, e.g. SP800-56Cr2).
 */
export type Primitive =
  | "drbg"
  | "mac"
  | "block-cipher"
  | "stream-cipher"
  | "signature"
  | "hash"
  | "pke"
  | "xof"
  | "kdf"
  | "key-agree"
  | "kem"
  | "ae"
  | "combiner"
  | "other"
  | "unknown";
/**
 * An identifier for the parameter set of the cryptographic algorithm. Examples: in AES128, '128' identifies the key length in bits, in SHA256, '256' identifies the digest length, '128' in SHAKE128 identifies its maximum security level in bits, and 'SHA2-128s' identifies a parameter set used in SLH-DSA (FIPS205).
 */
export type ParameterSetIdentifier = string;
/**
 * The specific underlying Elliptic Curve (EC) definition employed which is an indicator of the level of security strength, performance and complexity. Absent an authoritative source of curve names, CycloneDX recommends using curve names as defined at [https://neuromancer.sk/std/](https://neuromancer.sk/std/), the source of which can be found at [https://github.com/J08nY/std-curves](https://github.com/J08nY/std-curves).
 */
export type EllipticCurve = string;
/**
 * The target and execution environment in which the algorithm is implemented in.
 */
export type ExecutionEnvironment =
  | "software-plain-ram"
  | "software-encrypted-ram"
  | "software-tee"
  | "hardware"
  | "other"
  | "unknown";
/**
 * The target platform for which the algorithm is implemented. The implementation can be 'generic', running on any platform or for a specific platform.
 */
export type ImplementationPlatform =
  | "generic"
  | "x86_32"
  | "x86_64"
  | "armv7-a"
  | "armv7-m"
  | "armv8-a"
  | "armv8-m"
  | "armv9-a"
  | "armv9-m"
  | "s390x"
  | "ppc64"
  | "ppc64le"
  | "other"
  | "unknown";
/**
 * The certification that the implementation of the cryptographic algorithm has received, if any. Certifications include revisions and levels of FIPS 140 or Common Criteria of different Extended Assurance Levels (CC-EAL).
 */
export type CertificationLevel = (
  | "none"
  | "fips140-1-l1"
  | "fips140-1-l2"
  | "fips140-1-l3"
  | "fips140-1-l4"
  | "fips140-2-l1"
  | "fips140-2-l2"
  | "fips140-2-l3"
  | "fips140-2-l4"
  | "fips140-3-l1"
  | "fips140-3-l2"
  | "fips140-3-l3"
  | "fips140-3-l4"
  | "cc-eal1"
  | "cc-eal1+"
  | "cc-eal2"
  | "cc-eal2+"
  | "cc-eal3"
  | "cc-eal3+"
  | "cc-eal4"
  | "cc-eal4+"
  | "cc-eal5"
  | "cc-eal5+"
  | "cc-eal6"
  | "cc-eal6+"
  | "cc-eal7"
  | "cc-eal7+"
  | "other"
  | "unknown"
)[];
/**
 * The mode of operation in which the cryptographic algorithm (block cipher) is used.
 */
export type Mode = "cbc" | "ecb" | "ccm" | "gcm" | "cfb" | "ofb" | "ctr" | "other" | "unknown";
/**
 * The padding scheme that is used for the cryptographic algorithm.
 */
export type Padding = "pkcs5" | "pkcs7" | "pkcs1v15" | "oaep" | "raw" | "other" | "unknown";
/**
 * The cryptographic functions implemented by the cryptographic algorithm.
 */
export type CryptographicFunctions = (
  | "generate"
  | "keygen"
  | "encrypt"
  | "decrypt"
  | "digest"
  | "tag"
  | "keyderive"
  | "sign"
  | "verify"
  | "encapsulate"
  | "decapsulate"
  | "other"
  | "unknown"
)[];
/**
 * The classical security level that a cryptographic algorithm provides (in bits).
 */
export type ClassicalSecurityLevel = number;
/**
 * The NIST security strength category as defined in https://csrc.nist.gov/projects/post-quantum-cryptography/post-quantum-cryptography-standardization/evaluation-criteria/security-(evaluation-criteria). A value of 0 indicates that none of the categories are met.
 */
export type NISTSecurityStrengthCategory = number;
/**
 * The subject name for the certificate
 */
export type SubjectName = string;
/**
 * The issuer name for the certificate
 */
export type IssuerName = string;
/**
 * The date and time according to ISO-8601 standard from which the certificate is valid
 */
export type NotValidBefore = string;
/**
 * The date and time according to ISO-8601 standard from which the certificate is not valid anymore
 */
export type NotValidAfter = string;
/**
 * The bom-ref to signature algorithm used by the certificate
 */
export type AlgorithmReference = string;
/**
 * The bom-ref to the public key of the subject
 */
export type KeyReference = string;
/**
 * The format of the certificate
 */
export type CertificateFormat = string;
/**
 * The file extension of the certificate
 */
export type CertificateFileExtension = string;
/**
 * The type for the related cryptographic material
 */
export type RelatedCryptoMaterialType =
  | "private-key"
  | "public-key"
  | "secret-key"
  | "key"
  | "ciphertext"
  | "signature"
  | "digest"
  | "initialization-vector"
  | "nonce"
  | "seed"
  | "salt"
  | "shared-secret"
  | "tag"
  | "additional-data"
  | "password"
  | "credential"
  | "token"
  | "other"
  | "unknown";
/**
 * The optional unique identifier for the related cryptographic material.
 */
export type ID = string;
/**
 * The key state as defined by NIST SP 800-57.
 */
export type State = "pre-activation" | "active" | "suspended" | "deactivated" | "compromised" | "destroyed";
/**
 * The bom-ref to the algorithm used to generate the related cryptographic material.
 */
export type AlgorithmReference1 = string;
/**
 * The date and time (timestamp) when the related cryptographic material was created.
 */
export type CreationDate = string;
/**
 * The date and time (timestamp) when the related cryptographic material was activated.
 */
export type ActivationDate = string;
/**
 * The date and time (timestamp) when the related cryptographic material was updated.
 */
export type UpdateDate = string;
/**
 * The date and time (timestamp) when the related cryptographic material expires.
 */
export type ExpirationDate = string;
/**
 * The associated value of the cryptographic material.
 */
export type Value5 = string;
/**
 * The size of the cryptographic asset (in bits).
 */
export type Size = number;
/**
 * The format of the related cryptographic material (e.g. P8, PEM, DER).
 */
export type Format = string;
/**
 * Specifies the mechanism by which the cryptographic asset is secured by.
 */
export type Mechanism = string;
/**
 * The bom-ref to the algorithm.
 */
export type AlgorithmReference2 = string;
/**
 * The concrete protocol type.
 */
export type Type3 = "tls" | "ssh" | "ipsec" | "ike" | "sstp" | "wpa" | "other" | "unknown";
/**
 * The version of the protocol.
 */
export type ProtocolVersion = string;
/**
 * A common name for the cipher suite.
 */
export type CommonName = string;
/**
 * The bom-ref to algorithm cryptographic asset.
 */
export type AlgorithmReference3 = string;
/**
 * A list of algorithms related to the cipher suite.
 */
export type RelatedAlgorithms = AlgorithmReference3[];
/**
 * Cipher suite identifier
 */
export type Identifier = string;
/**
 * A list of common identifiers for the cipher suite.
 */
export type CipherSuiteIdentifiers = Identifier[];
/**
 * A list of cipher suites related to the protocol.
 */
export type CipherSuites = CipherSuite[];
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type RefType = string;
/**
 * Transform Type 1: encryption algorithms
 */
export type EncryptionAlgorithmENCR = RefType[];
/**
 * Transform Type 2: pseudorandom functions
 */
export type PseudorandomFunctionPRF = RefType[];
/**
 * Transform Type 3: integrity algorithms
 */
export type IntegrityAlgorithmINTEG = RefType[];
/**
 * Transform Type 4: Key Exchange Method (KE) per [RFC 9370](https://www.ietf.org/rfc/rfc9370.html), formerly called Diffie-Hellman Group (D-H).
 */
export type KeyExchangeMethodKE = RefType[];
/**
 * Specifies if an Extended Sequence Number (ESN) is used.
 */
export type ExtendedSequenceNumbersESN = boolean;
/**
 * IKEv2 Authentication method
 */
export type IKEv2AuthenticationMethod = RefType[];
/**
 * A list of protocol-related cryptographic assets
 */
export type CryptographicReferences = RefType[];
/**
 * The object identifier (OID) of the cryptographic asset.
 */
export type OID = string;
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties4 = LightweightNameValuePair[];
/**
 * Textual strings that aid in discovery, search, and retrieval of the associated object. Tags often serve as a way to group or categorize similar or related objects by various attributes.
 */
export type Tags1 = string[];
/**
 * Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
 */
export type Signature =
  | {
      signers?: Signature1;
    }
  | {
      chain?: Signature4;
    }
  | Signature5;
/**
 * Signature algorithm. The currently recognized JWA [RFC7518] and RFC8037 [RFC8037] asymmetric key algorithms. Note: Unlike RFC8037 [RFC8037] JSF requires explicit Ed* algorithm names instead of "EdDSA".
 */
export type Algorithm =
  | "RS256"
  | "RS384"
  | "RS512"
  | "PS256"
  | "PS384"
  | "PS512"
  | "ES256"
  | "ES384"
  | "ES512"
  | "Ed25519"
  | "Ed448"
  | "HS256"
  | "HS384"
  | "HS512";
/**
 * Signature algorithm. Note: If proprietary signature algorithms are added, they must be expressed as URIs.
 */
export type Algorithm1 = string;
/**
 * Optional. Application specific string identifying the signature key.
 */
export type KeyID = string;
/**
 * Optional. Public key object.
 */
export type PublicKey = {
  [k: string]: unknown;
};
/**
 * Optional. Sorted array of X.509 [RFC5280] certificates, where the first element must contain the signature certificate. The certificate path must be contiguous but is not required to be complete.
 */
export type CertificatePath = string[];
/**
 * Optional. Array holding the names of one or more application level properties that must be excluded from the signature process. Note that the "excludes" property itself, must also be excluded from the signature process. Since both the "excludes" property and the associated data it points to are unsigned, a conforming JSF implementation must provide options for specifying which properties to accept.
 */
export type Excludes = string[];
/**
 * The signature data. Note that the binary representation must follow the JWA [RFC7518] specifications.
 */
export type Signature3 = string;
/**
 * Unique top level property for Multiple Signatures. (multisignature)
 */
export type Signature1 = Signature2[];
/**
 * Unique top level property for Signature Chains. (signaturechain)
 */
export type Signature4 = Signature2[];
/**
 * A list of software and hardware components used as tools.
 */
export type Components = Component[];
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference9 = string;
/**
 * The grouping name, namespace, or identifier. This will often be a shortened, single name of the company or project that produced the service or domain name. Whitespace and special characters should be avoided.
 */
export type ServiceGroup = string;
/**
 * The name of the service. This will often be a shortened, single name of the service.
 */
export type ServiceName = string;
/**
 * The service version.
 */
export type ServiceVersion = string;
/**
 * Specifies a description for the service
 */
export type ServiceDescription = string;
/**
 * The endpoint URIs of the service. Multiple endpoints are allowed.
 */
export type Endpoints = string[];
/**
 * A boolean value indicating if the service requires authentication. A value of true indicates the service requires authentication prior to use. A value of false indicates the service does not require authentication.
 */
export type AuthenticationRequired = boolean;
/**
 * A boolean value indicating if use of the service crosses a trust zone or boundary. A value of true indicates that by using the service, a trust boundary is crossed. A value of false indicates that by using the service, a trust boundary is not crossed.
 */
export type CrossesTrustBoundary = boolean;
/**
 * The name of the trust zone the service resides in.
 */
export type TrustZone = string;
/**
 * Specifies the flow direction of the data. Direction is relative to the service. Inbound flow states that data enters the service. Outbound flow states that data leaves the service. Bi-directional states that data flows both ways and unknown states that the direction is not known.
 */
export type DirectionalFlow = "inbound" | "outbound" | "bi-directional" | "unknown";
/**
 * Name for the defined data
 */
export type Name8 = string;
/**
 * Short description of the data content and usage
 */
export type Description4 = string;
export type URL6 = string;
/**
 * Descriptor for an element in a BOM document. See https://cyclonedx.org/capabilities/bomlink/
 */
export type BOMLinkElement3 = string;
/**
 * The URI, URL, or BOM-Link of the components or services the data came in from
 */
export type Source1 = (URL6 | BOMLinkElement3)[];
export type URL7 = string;
/**
 * Descriptor for an element in a BOM document. See https://cyclonedx.org/capabilities/bomlink/
 */
export type BOMLinkElement4 = string;
/**
 * The URI, URL, or BOM-Link of the components or services the data is sent to
 */
export type Destination = (URL7 | BOMLinkElement4)[];
/**
 * Specifies information about the data including the directional flow of data and the data classification.
 */
export type Data1 = HashObjects[];
/**
 * EITHER (list of SPDX licenses and/or named licenses) OR (tuple of one SPDX License Expression)
 */
export type ServiceLicenseS = (MultipleLicenses | SPDXLicenseExpression) & unknown[];
/**
 * External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
 */
export type ExternalReferences2 = ExternalReference[];
/**
 * A list of services included or deployed behind the parent service. This is not a dependency tree. It provides a way to specify a hierarchical representation of service assemblies.
 */
export type Services1 = Service[];
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties5 = LightweightNameValuePair[];
/**
 * Textual strings that aid in discovery, search, and retrieval of the associated object. Tags often serve as a way to group or categorize similar or related objects by various attributes.
 */
export type Tags2 = string[];
/**
 * Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
 */
export type Signature6 =
  | {
      signers?: Signature1;
    }
  | {
      chain?: Signature4;
    }
  | Signature5;
/**
 * A list of services used as tools. This may include microservices, function-as-a-service, and other types of network or intra-process services.
 */
export type Services = Service[];
/**
 * The name of the vendor who created the tool
 */
export type ToolVendor = string;
/**
 * The name of the tool
 */
export type ToolName = string;
/**
 * The version of the tool
 */
export type ToolVersion = string;
/**
 * The hashes of the tool (if applicable).
 */
export type Hashes1 = Hash[];
/**
 * External references provide a way to document systems, sites, and information that may be relevant, but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
 */
export type ExternalReferences3 = ExternalReference[];
/**
 * [Deprecated] The tool(s) used in the creation, enrichment, and validation of the BOM.
 */
export type ToolsLegacy = Tool[];
/**
 * The person(s) who created the BOM.
 * Authors are common in BOMs created through manual processes. BOMs created through automated means may have `@.manufacturer` instead.
 */
export type BOMAuthors = OrganizationalContact1[];
/**
 * The license information for the BOM document.
 * This may be different from the license(s) of the component(s) that the BOM describes.
 */
export type BOMLicenseS = (MultipleLicenses | SPDXLicenseExpression) & unknown[];
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties6 = LightweightNameValuePair[];
/**
 * A list of software and hardware components.
 */
export type Components2 = Component[];
/**
 * A list of services. This may include microservices, function-as-a-service, and other types of network or intra-process services.
 */
export type Services2 = Service[];
/**
 * External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
 */
export type ExternalReferences4 = ExternalReference[];
/**
 * References a component or service by its bom-ref attribute
 */
export type Reference1 = string;
/**
 * The bom-ref identifiers of the components or services that are dependencies of this dependency object.
 */
export type DependsOn = string[];
/**
 * The bom-ref identifiers of the components or services that define a given specification or standard, which are provided or implemented by this dependency object.
 * For example, a cryptographic library which implements a cryptographic algorithm. A component which implements another component does not imply that the implementation is in use.
 */
export type Provides = string[];
/**
 * Provides the ability to document dependency relationships including provided & implemented components.
 */
export type Dependencies = Dependency[];
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference10 = string;
/**
 * Specifies an aggregate type that describe how complete a relationship is.
 */
export type Aggregate =
  | "complete"
  | "incomplete"
  | "incomplete_first_party_only"
  | "incomplete_first_party_proprietary_only"
  | "incomplete_first_party_opensource_only"
  | "incomplete_third_party_only"
  | "incomplete_third_party_proprietary_only"
  | "incomplete_third_party_opensource_only"
  | "unknown"
  | "not_specified";
/**
 * Descriptor for an element identified by the attribute 'bom-ref' in the same BOM document.
 * In contrast to `bomLinkElementType`.
 */
export type Ref2 = string;
/**
 * Descriptor for an element in a BOM document. See https://cyclonedx.org/capabilities/bomlink/
 */
export type BOMLinkElement5 = string;
/**
 * The bom-ref identifiers of the components or services being described. Assemblies refer to nested relationships whereby a constituent part may include other constituent parts. References do not cascade to child parts. References are explicit for the specified constituent part only.
 */
export type BOMReferences1 = (Ref2 | BOMLinkElement5)[];
/**
 * The bom-ref identifiers of the components or services being described. Dependencies refer to a relationship whereby an independent constituent part requires another independent constituent part. References do not cascade to transitive dependencies. References are explicit for the specified dependency only.
 */
export type BOMReferences2 = string[];
/**
 * The bom-ref identifiers of the vulnerabilities being described.
 */
export type BOMReferences3 = string[];
/**
 * Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
 */
export type Signature7 =
  | {
      signers?: Signature1;
    }
  | {
      chain?: Signature4;
    }
  | Signature5;
/**
 * Compositions describe constituent parts (including components, services, and dependency relationships) and their completeness. The completeness of vulnerabilities expressed in a BOM may also be described.
 */
export type Compositions = Compositions1[];
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference11 = string;
/**
 * The identifier that uniquely identifies the vulnerability.
 */
export type ID1 = string;
/**
 * The url of the vulnerability documentation as provided by the source.
 */
export type URL8 = string;
/**
 * The name of the source.
 */
export type Name9 = string;
/**
 * An identifier that uniquely identifies the vulnerability.
 */
export type ID2 = string;
/**
 * Zero or more pointers to vulnerabilities that are the equivalent of the vulnerability specified. Often times, the same vulnerability may exist in multiple sources of vulnerability intelligence, but have different identifiers. References provide a way to correlate vulnerabilities across multiple sources of vulnerability intelligence.
 */
export type References1 = {
  id: ID2;
  source: Source3;
}[];
/**
 * The numerical score of the rating.
 */
export type Score = number;
/**
 * Textual representation of the severity that corresponds to the numerical score of the rating.
 */
export type Severity = "critical" | "high" | "medium" | "low" | "info" | "none" | "unknown";
/**
 * Specifies the severity or risk scoring methodology or standard used.
 */
export type Method = "CVSSv2" | "CVSSv3" | "CVSSv31" | "CVSSv4" | "OWASP" | "SSVC" | "other";
/**
 * Textual representation of the metric values used to score the vulnerability
 */
export type Vector = string;
/**
 * An optional reason for rating the vulnerability as it was
 */
export type Justification = string;
/**
 * List of vulnerability ratings
 */
export type Ratings = Rating[];
/**
 * Integer representation of a Common Weaknesses Enumerations (CWE). For example 399 (of https://cwe.mitre.org/data/definitions/399.html)
 */
export type CWE = number;
/**
 * List of Common Weaknesses Enumerations (CWEs) codes that describes this vulnerability.
 */
export type CWEs = CWE[];
/**
 * A description of the vulnerability as provided by the source.
 */
export type Description5 = string;
/**
 * If available, an in-depth description of the vulnerability as provided by the source organization. Details often include information useful in understanding root cause.
 */
export type Details = string;
/**
 * Recommendations of how the vulnerability can be remediated or mitigated.
 */
export type Recommendation = string;
/**
 * A bypass, usually temporary, of the vulnerability that reduces its likelihood and/or impact. Workarounds often involve changes to configuration or deployments.
 */
export type Workarounds = string;
/**
 * Precise steps to reproduce the vulnerability.
 */
export type StepsToReproduce = string;
/**
 * A description of the environment in which reproduction was possible.
 */
export type Environment = string;
/**
 * Supporting material that helps in reproducing or understanding how reproduction is possible. This may include screenshots, payloads, and PoC exploit code.
 */
export type SupportingMaterial = Attachment[];
/**
 * An optional name of the advisory.
 */
export type Title1 = string;
/**
 * Location where the advisory can be obtained.
 */
export type URL9 = string;
/**
 * Published advisories of the vulnerability if provided.
 */
export type Advisories = Advisory[];
/**
 * The date and time (timestamp) when the vulnerability record was created in the vulnerability database.
 */
export type Created = string;
/**
 * The date and time (timestamp) when the vulnerability record was first published.
 */
export type Published = string;
/**
 * The date and time (timestamp) when the vulnerability record was last updated.
 */
export type Updated = string;
/**
 * The date and time (timestamp) when the vulnerability record was rejected (if applicable).
 */
export type Rejected = string;
/**
 * The organizations credited with vulnerability discovery.
 */
export type Organizations = OrganizationalEntity[];
/**
 * The individuals, not associated with organizations, that are credited with vulnerability discovery.
 */
export type Individuals = OrganizationalContact1[];
/**
 * The tool(s) used to identify, confirm, or score the vulnerability.
 */
export type Tools2 = Tools3 | ToolsLegacy1;
/**
 * A list of software and hardware components used as tools.
 */
export type Components3 = Component[];
/**
 * A list of services used as tools. This may include microservices, function-as-a-service, and other types of network or intra-process services.
 */
export type Services3 = Service[];
/**
 * [Deprecated] The tool(s) used to identify, confirm, or score the vulnerability.
 */
export type ToolsLegacy1 = Tool[];
/**
 * Declares the current state of an occurrence of a vulnerability, after automated or manual analysis.
 */
export type ImpactAnalysisState =
  | "resolved"
  | "resolved_with_pedigree"
  | "exploitable"
  | "in_triage"
  | "false_positive"
  | "not_affected";
/**
 * The rationale of why the impact analysis state was asserted.
 */
export type ImpactAnalysisJustification =
  | "code_not_present"
  | "code_not_reachable"
  | "requires_configuration"
  | "requires_dependency"
  | "requires_environment"
  | "protected_by_compiler"
  | "protected_at_runtime"
  | "protected_at_perimeter"
  | "protected_by_mitigating_control";
/**
 * A response to the vulnerability by the manufacturer, supplier, or project responsible for the affected component or service. More than one response is allowed. Responses are strongly encouraged for vulnerabilities where the analysis state is exploitable.
 */
export type Response = ("can_not_fix" | "will_not_fix" | "update" | "rollback" | "workaround_available")[];
/**
 * Detailed description of the impact including methods used during assessment. If a vulnerability is not exploitable, this field should include specific details on why the component or service is not impacted by this vulnerability.
 */
export type Detail = string;
/**
 * The date and time (timestamp) when the analysis was first issued.
 */
export type FirstIssued = string;
/**
 * The date and time (timestamp) when the analysis was last updated.
 */
export type LastUpdated = string;
/**
 * References a component or service by the objects bom-ref
 */
export type Reference2 = Ref3 | BOMLinkElement6;
/**
 * Descriptor for an element identified by the attribute 'bom-ref' in the same BOM document.
 * In contrast to `bomLinkElementType`.
 */
export type Ref3 = string;
/**
 * Descriptor for an element in a BOM document. See https://cyclonedx.org/capabilities/bomlink/
 */
export type BOMLinkElement6 = string;
/**
 * Zero or more individual versions or range of versions.
 */
export type Versions = {
  [k: string]: unknown;
}[];
/**
 * The components or services that are affected by the vulnerability.
 */
export type Affects = {
  ref: Reference2;
  versions?: Versions;
}[];
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties7 = LightweightNameValuePair[];
/**
 * Vulnerabilities identified in components or services.
 */
export type Vulnerabilities = Vulnerability[];
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference12 = string;
/**
 * Descriptor for an element identified by the attribute 'bom-ref' in the same BOM document.
 * In contrast to `bomLinkElementType`.
 */
export type Ref4 = string;
/**
 * Descriptor for an element in a BOM document. See https://cyclonedx.org/capabilities/bomlink/
 */
export type BOMLinkElement7 = string;
/**
 * The object in the BOM identified by its bom-ref. This is often a component or service, but may be any object type supporting bom-refs.
 */
export type Subjects = (Ref4 | BOMLinkElement7)[];
/**
 * The organization, person, component, or service which created the textual content of the annotation.
 */
export type Annotator = {
  [k: string]: unknown;
};
/**
 * The date and time (timestamp) when the annotation was created.
 */
export type Timestamp3 = string;
/**
 * The textual content of the annotation.
 */
export type Text = string;
/**
 * Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
 */
export type Signature8 =
  | {
      signers?: Signature1;
    }
  | {
      chain?: Signature4;
    }
  | Signature5;
/**
 * Comments made by people, organizations, or tools about any object with a bom-ref, such as components, services, vulnerabilities, or the BOM itself. Unlike inventory information, annotations may contain opinions or commentary from various stakeholders. Annotations may be inline (with inventory) or externalized via BOM-Link and may optionally be signed.
 */
export type Annotations = Annotations1[];
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference13 = string;
/**
 * Transient components that are used in tasks that constitute one or more of this formula's workflows
 */
export type Components4 = Component[];
/**
 * Transient services that are used in tasks that constitute one or more of this formula's workflows
 */
export type Services4 = Service[];
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference14 = string;
/**
 * The unique identifier for the resource instance within its deployment context.
 */
export type UniqueIdentifierUID = string;
/**
 * The name of the resource instance.
 */
export type Name10 = string;
/**
 * A description of the resource instance.
 */
export type Description6 = string;
/**
 * A reference to a locally defined resource (e.g., a bom-ref) or an externally accessible resource.
 */
export type ResourceReferenceChoice = {
  [k: string]: unknown;
};
/**
 * References to component or service resources that are used to realize the resource instance.
 */
export type ResourceReferences = ResourceReferenceChoice[];
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference15 = string;
/**
 * The unique identifier for the resource instance within its deployment context.
 */
export type UniqueIdentifierUID1 = string;
/**
 * The name of the resource instance.
 */
export type Name11 = string;
/**
 * A description of the resource instance.
 */
export type Description7 = string;
/**
 * References to component or service resources that are used to realize the resource instance.
 */
export type ResourceReferences1 = ResourceReferenceChoice[];
export type TaskType =
  | "copy"
  | "clone"
  | "lint"
  | "scan"
  | "merge"
  | "build"
  | "test"
  | "deliver"
  | "deploy"
  | "release"
  | "clean"
  | "other";
/**
 * Indicates the types of activities performed by the set of workflow tasks.
 */
export type TaskTypes = TaskType[];
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference16 = string;
/**
 * The unique identifier for the resource instance within its deployment context.
 */
export type UniqueIdentifierUID2 = string;
/**
 * The name of the resource instance.
 */
export type Name12 = string;
/**
 * A description of the resource instance.
 */
export type Description8 = string;
/**
 * References to component or service resources that are used to realize the resource instance.
 */
export type ResourceReferences2 = ResourceReferenceChoice[];
/**
 * The source type of event which caused the trigger to fire.
 */
export type Type4 = "manual" | "api" | "webhook" | "scheduled";
/**
 * The unique identifier of the event.
 */
export type UniqueIdentifierUID3 = string;
/**
 * A description of the event.
 */
export type Description9 = string;
/**
 * The date and time (timestamp) when the event was received.
 */
export type TimeReceived = string;
/**
 * A reference to a locally defined resource (e.g., a bom-ref) or an externally accessible resource.
 */
export type ResourceReferenceChoice1 = {
  [k: string]: unknown;
};
/**
 * A reference to a locally defined resource (e.g., a bom-ref) or an externally accessible resource.
 */
export type ResourceReferenceChoice2 = {
  [k: string]: unknown;
};
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties8 = LightweightNameValuePair[];
/**
 * Describes the set of conditions which cause the trigger to activate.
 */
export type Description10 = string;
/**
 * The logical expression that was evaluated that determined the trigger should be fired.
 */
export type Expression = string;
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties9 = LightweightNameValuePair[];
/**
 * A list of conditions used to determine if a trigger should be activated.
 */
export type Conditions = Condition[];
/**
 * The date and time (timestamp) when the trigger was activated.
 */
export type TimeActivated = string;
/**
 * Type that represents various input data types and formats.
 */
export type InputType = {
  [k: string]: unknown;
};
/**
 * Represents resources and data brought into a task at runtime by executor or task commands
 */
export type Inputs1 = InputType[];
export type OutputType = {
  type?: Type5;
  source?: ResourceReferenceChoice3;
  target?: ResourceReferenceChoice4;
  resource?: ResourceReferenceChoice5;
  data?: Attachment2;
  environmentVars?: EnvironmentVariables;
  properties?: Properties10;
} & OutputType1;
/**
 * Describes the type of data output.
 */
export type Type5 = "artifact" | "attestation" | "log" | "evidence" | "metrics" | "other";
/**
 * A reference to a locally defined resource (e.g., a bom-ref) or an externally accessible resource.
 */
export type ResourceReferenceChoice3 = {
  [k: string]: unknown;
};
/**
 * A reference to a locally defined resource (e.g., a bom-ref) or an externally accessible resource.
 */
export type ResourceReferenceChoice4 = {
  [k: string]: unknown;
};
/**
 * A reference to a locally defined resource (e.g., a bom-ref) or an externally accessible resource.
 */
export type ResourceReferenceChoice5 = {
  [k: string]: unknown;
};
/**
 * Outputs that have the form of environment variables.
 */
export type EnvironmentVariables = (LightweightNameValuePair | string)[];
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties10 = LightweightNameValuePair[];
export type OutputType1 = {
  [k: string]: unknown;
};
/**
 * Represents resources and data output from a task at runtime by executor or task commands
 */
export type Outputs1 = OutputType[];
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties11 = LightweightNameValuePair[];
/**
 * A name for the step.
 */
export type Name13 = string;
/**
 * A description of the step.
 */
export type Description11 = string;
/**
 * A text representation of the executed command.
 */
export type Executed = string;
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties12 = LightweightNameValuePair[];
/**
 * Ordered list of commands or directives for the step
 */
export type Commands = Command[];
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties13 = LightweightNameValuePair[];
/**
 * The sequence of steps for the task.
 */
export type Steps = Step[];
/**
 * Represents resources and data brought into a task at runtime by executor or task commands
 */
export type Inputs2 = InputType[];
/**
 * Represents resources and data output from a task at runtime by executor or task commands
 */
export type Outputs2 = OutputType[];
/**
 * The date and time (timestamp) when the task started.
 */
export type TimeStart = string;
/**
 * The date and time (timestamp) when the task ended.
 */
export type TimeEnd = string;
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference17 = string;
/**
 * The unique identifier for the resource instance within its deployment context.
 */
export type UniqueIdentifierUID4 = string;
/**
 * The name of the resource instance.
 */
export type Name14 = string;
/**
 * The names for the workspace as referenced by other workflow tasks. Effectively, a name mapping so other tasks can use their own local name in their steps.
 */
export type Aliases1 = string[];
/**
 * A description of the resource instance.
 */
export type Description12 = string;
/**
 * References to component or service resources that are used to realize the resource instance.
 */
export type ResourceReferences3 = ResourceReferenceChoice[];
/**
 * Describes the read-write access control for the workspace relative to the owning resource instance.
 */
export type AccessMode = "read-only" | "read-write" | "read-write-once" | "write-once" | "write-only";
/**
 * A path to a location on disk where the workspace will be available to the associated task's steps.
 */
export type MountPath = string;
/**
 * The name of a domain-specific data type the workspace represents.
 */
export type ManagedDataType = string;
/**
 * Identifies the reference to the request for a specific volume type and parameters.
 */
export type VolumeRequest = string;
/**
 * The unique identifier for the volume instance within its deployment context.
 */
export type UniqueIdentifierUID5 = string;
/**
 * The name of the volume instance
 */
export type Name15 = string;
/**
 * The mode for the volume instance.
 */
export type Mode1 = "filesystem" | "block";
/**
 * The underlying path created from the actual volume.
 */
export type Path = string;
/**
 * The allocated size of the volume accessible to the associated workspace. This should include the scalar size as well as IEC standard unit in either decimal or binary form.
 */
export type SizeAllocated = string;
/**
 * Indicates if the volume persists beyond the life of the resource it is associated with.
 */
export type Persistent = boolean;
/**
 * Indicates if the volume is remotely (i.e., network) attached.
 */
export type Remote = boolean;
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties14 = LightweightNameValuePair[];
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties15 = LightweightNameValuePair[];
/**
 * A set of named filesystem or data resource shareable by workflow tasks.
 */
export type Workspaces = Workspace[];
/**
 * A graph of the component runtime topology for task's instance.
 */
export type RuntimeTopology = Dependency[];
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties16 = LightweightNameValuePair[];
/**
 * The tasks that comprise the workflow.
 */
export type Tasks = Task1[];
/**
 * The graph of dependencies between tasks within the workflow.
 */
export type TaskDependencyGraph = Dependency[];
/**
 * Indicates the types of activities performed by the set of workflow tasks.
 */
export type TaskTypes1 = TaskType[];
/**
 * The sequence of steps for the task.
 */
export type Steps1 = Step[];
/**
 * Represents resources and data brought into a task at runtime by executor or task commands
 */
export type Inputs3 = InputType[];
/**
 * Represents resources and data output from a task at runtime by executor or task commands
 */
export type Outputs3 = OutputType[];
/**
 * The date and time (timestamp) when the task started.
 */
export type TimeStart1 = string;
/**
 * The date and time (timestamp) when the task ended.
 */
export type TimeEnd1 = string;
/**
 * A set of named filesystem or data resource shareable by workflow tasks.
 */
export type Workspaces1 = Workspace[];
/**
 * A graph of the component runtime topology for workflow's instance.
 */
export type RuntimeTopology1 = Dependency[];
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties17 = LightweightNameValuePair[];
/**
 * List of workflows that can be declared to accomplish specific orchestrated goals and independently triggered.
 */
export type Workflows = Workflow[];
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties18 = LightweightNameValuePair[];
/**
 * Describes how a component or service was manufactured or deployed. This is achieved through the use of formulas, workflows, tasks, and steps, which declare the precise steps to reproduce along with the observed formulas describing the steps which transpired in the manufacturing process.
 */
export type Formulation = Formula[];
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference18 = string;
/**
 * The boolean indicating if the assessor is outside the organization generating claims. A value of false indicates a self assessor.
 */
export type ThirdParty = boolean;
/**
 * The list of assessors evaluating claims and determining conformance to requirements and confidence in that assessment.
 */
export type Assessors = Assessor[];
/**
 * The short description explaining the main points of the attestation.
 */
export type Summary = string;
/**
 * Descriptor for an element identified by the attribute 'bom-ref' in the same BOM document.
 * In contrast to `bomLinkElementType`.
 */
export type Assessor1 = string;
/**
 * Descriptor for an element identified by the attribute 'bom-ref' in the same BOM document.
 * In contrast to `bomLinkElementType`.
 */
export type Requirement = string;
/**
 * The list of `bom-ref` to the claims being attested to.
 */
export type Claims = string[];
/**
 * The list of  `bom-ref` to the counter claims being attested to.
 */
export type CounterClaims = string[];
/**
 * The conformance of the claim between and inclusive of 0 and 1, where 1 is 100% conformance.
 */
export type Score1 = number;
/**
 * The rationale for the conformance score.
 */
export type Rationale = string;
/**
 * The list of  `bom-ref` to the evidence provided describing the mitigation strategies.
 */
export type MitigationStrategies = string[];
/**
 * The confidence of the claim between and inclusive of 0 and 1, where 1 is 100% confidence.
 */
export type Score2 = number;
/**
 * The rationale for the confidence score.
 */
export type Rationale1 = string;
/**
 * The grouping of requirements to claims and the attestors declared conformance and confidence thereof.
 */
export type Map = Map1[];
/**
 * Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
 */
export type Signature9 =
  | {
      signers?: Signature1;
    }
  | {
      chain?: Signature4;
    }
  | Signature5;
/**
 * The list of attestations asserted by an assessor that maps requirements to claims.
 */
export type Attestations = Attestation[];
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference19 = string;
/**
 * Descriptor for an element identified by the attribute 'bom-ref' in the same BOM document.
 * In contrast to `bomLinkElementType`.
 */
export type Target = string;
/**
 * The specific statement or assertion about the target.
 */
export type Predicate = string;
/**
 * The list of  `bom-ref` to the evidence provided describing the mitigation strategies. Each mitigation strategy should include an explanation of how any weaknesses in the evidence will be mitigated.
 */
export type MitigationStrategies1 = string[];
/**
 * The written explanation of why the evidence provided substantiates the claim.
 */
export type Reasoning = string;
/**
 * The list of `bom-ref` to evidence that supports this claim.
 */
export type Evidence1 = string[];
/**
 * The list of `bom-ref` to counterEvidence that supports this claim.
 */
export type CounterEvidence = string[];
/**
 * External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
 */
export type ExternalReferences5 = ExternalReference[];
/**
 * Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
 */
export type Signature10 =
  | {
      signers?: Signature1;
    }
  | {
      chain?: Signature4;
    }
  | Signature5;
/**
 * The list of claims.
 */
export type Claims1 = Claim[];
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference20 = string;
/**
 * The reference to the property name as defined in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy/).
 */
export type PropertyName = string;
/**
 * The written description of what this evidence is and how it was created.
 */
export type Description13 = string;
/**
 * The name of the data.
 */
export type DataName = string;
/**
 * The URL to where the data can be retrieved.
 */
export type DataURL1 = string;
/**
 * A description of any sensitive data included.
 */
export type SensitiveData1 = string[];
/**
 * The output or analysis that supports claims.
 */
export type Data2 = Data3[];
/**
 * The date and time (timestamp) when the evidence was created.
 */
export type Created1 = string;
/**
 * The optional date and time (timestamp) when the evidence is no longer valid.
 */
export type Expires = string;
/**
 * Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
 */
export type Signature11 =
  | {
      signers?: Signature1;
    }
  | {
      chain?: Signature4;
    }
  | Signature5;
/**
 * The list of evidence
 */
export type Evidence2 = Evidence3[];
/**
 * The list of organizations which claims are made against.
 */
export type Organizations1 = OrganizationalEntity[];
/**
 * The list of components which claims are made against.
 */
export type Components5 = Component[];
/**
 * The list of services which claims are made against.
 */
export type Services5 = Service[];
/**
 * The brief statement affirmed by an individual regarding all declarations.
 * *- Notes This could be an affirmation of acceptance by a third-party auditor or receiving individual of a file.
 */
export type Statement = string;
export type Signatory = {
  [k: string]: unknown;
};
/**
 * The list of signatories authorized on behalf of an organization to assert validity of this document.
 */
export type Signatories = Signatory[];
/**
 * Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
 */
export type Signature12 =
  | {
      signers?: Signature1;
    }
  | {
      chain?: Signature4;
    }
  | Signature5;
/**
 * Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
 */
export type Signature13 =
  | {
      signers?: Signature1;
    }
  | {
      chain?: Signature4;
    }
  | Signature5;
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference21 = string;
/**
 * The name of the standard. This will often be a shortened, single name of the standard.
 */
export type Name16 = string;
/**
 * The version of the standard.
 */
export type Version1 = string;
/**
 * The description of the standard.
 */
export type Description14 = string;
/**
 * The owner of the standard, often the entity responsible for its release.
 */
export type Owner = string;
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference22 = string;
/**
 * The unique identifier used in the standard to identify a specific requirement. This should match what is in the standard and should not be the requirements bom-ref.
 */
export type Identifier1 = string;
/**
 * The title of the requirement.
 */
export type Title2 = string;
/**
 * The textual content of the requirement.
 */
export type Text1 = string;
/**
 * The supplemental text that provides additional guidance or context to the requirement, but is not directly part of the requirement.
 */
export type Descriptions = string[];
/**
 * The Common Requirements Enumeration (CRE) identifier(s). CRE is a structured and standardized framework for uniting security standards and guidelines. CRE links each section of a resource to a shared topic identifier (a Common Requirement). Through this shared topic link, all resources map to each other. Use of CRE promotes clear and unambiguous communication among stakeholders.
 */
export type OWASPOpenCREIdentifierS = string[];
/**
 * Descriptor for an element identified by the attribute 'bom-ref' in the same BOM document.
 * In contrast to `bomLinkElementType`.
 */
export type ParentBOMReference = string;
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties19 = LightweightNameValuePair[];
/**
 * External references provide a way to document systems, sites, and information that may be relevant, but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
 */
export type ExternalReferences6 = ExternalReference[];
/**
 * The list of requirements comprising the standard.
 */
export type Requirements = Requirement1[];
/**
 * Identifier for referable and therefore interlinkable elements.
 * Value SHOULD not start with the BOM-Link intro 'urn:cdx:' to avoid conflicts with BOM-Links.
 */
export type BOMReference23 = string;
/**
 * The identifier used in the standard to identify a specific level.
 */
export type Identifier2 = string;
/**
 * The title of the level.
 */
export type Title3 = string;
/**
 * The description of the level.
 */
export type Description15 = string;
/**
 * The list of requirement `bom-ref`s that comprise the level.
 */
export type Requirements1 = string[];
/**
 * The list of levels associated with the standard. Some standards have different levels of compliance.
 */
export type Levels = Level[];
/**
 * External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
 */
export type ExternalReferences7 = ExternalReference[];
/**
 * Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
 */
export type Signature14 =
  | {
      signers?: Signature1;
    }
  | {
      chain?: Signature4;
    }
  | Signature5;
/**
 * The list of standards which may consist of regulations, industry or organizational-specific standards, maturity models, best practices, or any other requirements which can be evaluated against or attested to.
 */
export type Standards = Standard[];
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export type Properties20 = LightweightNameValuePair[];
/**
 * Enveloped signature in [JSON Signature Format (JSF)](https://cyberphone.github.io/doc/security/jsf.html).
 */
export type Signature15 =
  | {
      signers?: Signature1;
    }
  | {
      chain?: Signature4;
    }
  | Signature5;

export interface CycloneDXBillOfMaterialsStandard {
  $schema?: string;
  bomFormat: BOMFormat;
  specVersion: CycloneDXSpecificationVersion;
  serialNumber?: BOMSerialNumber;
  version?: BOMVersion;
  metadata?: BOMMetadata;
  components?: Components2;
  services?: Services2;
  externalReferences?: ExternalReferences4;
  dependencies?: Dependencies;
  compositions?: Compositions;
  vulnerabilities?: Vulnerabilities;
  annotations?: Annotations;
  formulation?: Formulation;
  declarations?: Declarations;
  definitions?: Definitions;
  properties?: Properties20;
  signature?: Signature15;
}
/**
 * Provides additional information about a BOM.
 */
export interface BOMMetadata {
  timestamp?: Timestamp;
  lifecycles?: Lifecycles;
  tools?: Tools;
  manufacturer?: BOMManufacturer;
  authors?: BOMAuthors;
  component?: Component1;
  manufacture?: ComponentManufactureLegacy;
  supplier?: Supplier;
  licenses?: BOMLicenseS;
  properties?: Properties6;
}
export interface PreDefinedPhase {
  phase: Phase;
}
export interface CustomPhase {
  name: Name;
  description?: Description;
}
/**
 * The tool(s) used in the creation, enrichment, and validation of the BOM.
 */
export interface Tools1 {
  components?: Components;
  services?: Services;
}
export interface Component {
  type: ComponentType;
  "mime-type"?: MimeType;
  "bom-ref"?: BOMReference;
  supplier?: ComponentSupplier;
  manufacturer?: ComponentManufacturer;
  authors?: ComponentAuthors;
  author?: ComponentAuthorLegacy;
  publisher?: ComponentPublisher;
  group?: ComponentGroup;
  name: ComponentName;
  version?: ComponentVersion;
  description?: ComponentDescription;
  scope?: ComponentScope;
  hashes?: ComponentHashes;
  licenses?: ComponentLicenseS;
  copyright?: ComponentCopyright;
  cpe?: CommonPlatformEnumerationCPE;
  purl?: PackageURLPurl;
  omniborId?: OmniBORArtifactIdentifierGitoid;
  swhid?: SoftwareHeritageIdentifier;
  swid?: SWIDTag;
  modified?: ComponentModifiedFromOriginal;
  pedigree?: ComponentPedigree;
  externalReferences?: ExternalReferences;
  components?: Components1;
  evidence?: Evidence;
  releaseNotes?: ReleaseNotes;
  modelCard?: AIMLModelCard;
  data?: Data;
  cryptoProperties?: CryptographicProperties;
  properties?: Properties4;
  tags?: Tags1;
  signature?: Signature;
}
/**
 *  The organization that supplied the component. The supplier may often be the manufacturer, but may also be a distributor or repackager.
 */
export interface ComponentSupplier {
  "bom-ref"?: BOMReference1;
  name?: OrganizationName;
  address?: OrganizationAddress;
  url?: OrganizationURLS;
  contact?: OrganizationalContact;
}
/**
 * The physical address (location) of the organization
 */
export interface OrganizationAddress {
  "bom-ref"?: BOMReference2;
  country?: Country;
  region?: Region;
  locality?: Locality;
  postOfficeBoxNumber?: PostOfficeBoxNumber;
  postalCode?: PostalCode;
  streetAddress?: StreetAddress;
}
export interface OrganizationalContact1 {
  "bom-ref"?: BOMReference3;
  name?: Name1;
  email?: EmailAddress;
  phone?: Phone;
}
/**
 * The organization that created the component.
 * Manufacturer is common in components created through automated processes. Components created through manual means may have `@.authors` instead.
 */
export interface ComponentManufacturer {
  "bom-ref"?: BOMReference1;
  name?: OrganizationName;
  address?: OrganizationAddress;
  url?: OrganizationURLS;
  contact?: OrganizationalContact;
}
export interface Hash {
  alg: HashAlgorithm;
  content: HashValue;
}
export interface License {
  license: License1;
}
/**
 * Asserts the identity of the component using [ISO-IEC 19770-2 Software Identification (SWID) Tags](https://www.iso.org/standard/65666.html). Refer to `@.evidence.identity` to optionally provide evidence that substantiates the assertion of the component's identity.
 */
export interface SWIDTag {
  tagId: TagID;
  name: Name2;
  version?: Version;
  tagVersion?: TagVersion;
  patch?: Patch;
  text?: AttachmentText;
  url?: URL;
}
/**
 * Specifies the metadata and content of the SWID tag.
 */
export interface AttachmentText {
  contentType?: ContentType;
  encoding?: Encoding;
  content: AttachmentText1;
}
/**
 * Component pedigree is a way to document complex supply chain scenarios where components are created, distributed, modified, redistributed, combined with other components, etc. Pedigree supports viewing this complex chain from the beginning, the end, or anywhere in the middle. It also provides a way to document variants where the exact relation may not be known.
 */
export interface ComponentPedigree {
  ancestors?: Ancestors;
  descendants?: Descendants;
  variants?: Variants;
  commits?: Commits;
  patches?: Patches;
  notes?: Notes;
}
/**
 * Specifies an individual commit
 */
export interface Commit {
  uid?: UID;
  url?: URL1;
  author?: Author;
  committer?: Committer;
  message?: Message;
}
/**
 * The author who created the changes in the commit
 */
export interface Author {
  timestamp?: Timestamp1;
  name?: Name3;
  email?: EMail;
}
/**
 * The person who committed or pushed the commit
 */
export interface Committer {
  timestamp?: Timestamp1;
  name?: Name3;
  email?: EMail;
}
/**
 * Specifies an individual patch
 */
export interface Patch1 {
  type: PatchType;
  diff?: Diff;
  resolves?: Resolves;
}
/**
 * The patch file (or diff) that shows changes. Refer to [https://en.wikipedia.org/wiki/Diff](https://en.wikipedia.org/wiki/Diff)
 */
export interface Diff {
  text?: DiffText;
  url?: URL2;
}
/**
 * Specifies the optional text of the diff
 */
export interface DiffText {
  contentType?: ContentType;
  encoding?: Encoding;
  content: AttachmentText1;
}
/**
 * An individual issue that has been resolved.
 */
export interface Issue {
  type: IssueType;
  id?: IssueID;
  name?: IssueName;
  description?: IssueDescription;
  source?: Source;
  references?: References;
}
/**
 * The source of the issue where it is documented
 */
export interface Source {
  name?: Name4;
  url?: URL3;
}
/**
 * External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
 */
export interface ExternalReference {
  url: URL4;
  comment?: Comment;
  type: Type;
  hashes?: Hashes;
}
/**
 * Provides the ability to document evidence collected through various forms of extraction or analysis.
 */
export interface Evidence {
  identity?: IdentityEvidence;
  occurrences?: Occurrences;
  callstack?: CallStack;
  licenses?: LicenseEvidence;
  copyright?: CopyrightEvidence;
}
/**
 * Evidence that substantiates the identity of a component.
 */
export interface IdentityEvidence1 {
  field: Field;
  confidence?: Confidence;
  concludedValue?: ConcludedValue;
  methods?: Methods;
  tools?: BOMReferences;
}
/**
 * @deprecated
 * Evidence that substantiates the identity of a component.
 */
export interface IdentityEvidence2 {
  field: Field;
  confidence?: Confidence;
  concludedValue?: ConcludedValue;
  methods?: Methods;
  tools?: BOMReferences;
}
/**
 * Evidence of the components use through the callstack.
 */
export interface CallStack {
  frames?: Frames;
}
/**
 * A copyright notice informing users of the underlying claims to copyright ownership in a published work.
 */
export interface Copyright {
  text: CopyrightText;
}
/**
 * Specifies optional release notes.
 */
export interface ReleaseNotes {
  type: Type1;
  title?: Title;
  featuredImage?: FeaturedImage;
  socialImage?: SocialImage;
  description?: Description1;
  timestamp?: Timestamp2;
  aliases?: Aliases;
  tags?: Tags;
  resolves?: Resolves1;
  notes?: Notes1;
  properties?: Properties;
}
/**
 * A note containing the locale and content.
 */
export interface Note {
  locale?: Locale;
  text: ReleaseNoteContent;
}
/**
 * Specifies the full content of the release note.
 */
export interface ReleaseNoteContent {
  contentType?: ContentType;
  encoding?: Encoding;
  content: AttachmentText1;
}
/**
 * Provides the ability to document properties in a name-value store. This provides flexibility to include data not officially supported in the standard without having to use additional namespaces or create extensions. Unlike key-value stores, properties support duplicate names, each potentially having different values. Property names of interest to the general public are encouraged to be registered in the [CycloneDX Property Taxonomy](https://github.com/CycloneDX/cyclonedx-property-taxonomy). Formal registration is optional.
 */
export interface LightweightNameValuePair {
  name: Name5;
  value?: Value1;
}
/**
 * A model card describes the intended uses of a machine learning model and potential limitations, including biases and ethical considerations. Model cards typically contain the training parameters, which datasets were used to train the model, performance metrics, and other relevant data useful for ML transparency. This object SHOULD be specified for any component of type `machine-learning-model` and must not be specified for other component types.
 */
export interface AIMLModelCard {
  "bom-ref"?: BOMReference6;
  modelParameters?: ModelParameters;
  quantitativeAnalysis?: QuantitativeAnalysis;
  considerations?: Considerations;
  properties?: Properties3;
}
/**
 * Hyper-parameters for construction of the model.
 */
export interface ModelParameters {
  approach?: Approach;
  task?: Task;
  architectureFamily?: ArchitectureFamily;
  modelArchitecture?: ModelArchitecture;
  datasets?: Datasets;
  inputs?: Inputs;
  outputs?: Outputs;
}
/**
 * The overall approach to learning used by the model for problem solving.
 */
export interface Approach {
  type?: LearningType;
}
export interface InlineDataInformation {
  "bom-ref"?: BOMReference7;
  type: TypeOfData;
  name?: DatasetName;
  contents?: DataContents;
  classification?: DataClassification;
  sensitiveData?: SensitiveData;
  graphics?: GraphicsCollection;
  description?: DatasetDescription;
  governance?: DataGovernance;
}
/**
 * The contents or references to the contents of the data being described.
 */
export interface DataContents {
  attachment?: DataAttachment;
  url?: DataURL;
  properties?: ConfigurationProperties;
}
/**
 * An optional way to include textual or encoded data.
 */
export interface DataAttachment {
  contentType?: ContentType;
  encoding?: Encoding;
  content: AttachmentText1;
}
/**
 * A collection of graphics that represent various measurements.
 */
export interface GraphicsCollection {
  description?: Description2;
  collection?: Collection;
}
export interface Graphic {
  name?: Name6;
  image?: GraphicImage;
}
/**
 * The graphic (vector or raster). Base64 encoding must be specified for binary images.
 */
export interface GraphicImage {
  contentType?: ContentType;
  encoding?: Encoding;
  content: AttachmentText1;
}
/**
 * Data governance captures information regarding data ownership, stewardship, and custodianship, providing insights into the individuals or entities responsible for managing, overseeing, and safeguarding the data throughout its lifecycle.
 */
export interface DataGovernance {
  custodians?: DataCustodians;
  stewards?: DataStewards;
  owners?: DataOwners;
}
/**
 * The organization that is responsible for specific data governance role(s).
 */
export interface Organization {
  "bom-ref"?: BOMReference1;
  name?: OrganizationName;
  address?: OrganizationAddress;
  url?: OrganizationURLS;
  contact?: OrganizationalContact;
}
/**
 * The individual that is responsible for specific data governance role(s).
 */
export interface OrganizationalContact2 {
  "bom-ref"?: BOMReference3;
  name?: Name1;
  email?: EmailAddress;
  phone?: Phone;
}
export interface DataReference {
  ref?: Reference;
}
export interface InputAndOutputParameters {
  format?: InputOutputFormat;
}
/**
 * A quantitative analysis of the model
 */
export interface QuantitativeAnalysis {
  performanceMetrics?: PerformanceMetrics;
  graphics?: GraphicsCollection;
}
export interface PerformanceMetric {
  type?: Type2;
  value?: Value2;
  slice?: Slice;
  confidenceInterval?: ConfidenceInterval;
}
/**
 * The confidence interval of the metric.
 */
export interface ConfidenceInterval {
  lowerBound?: LowerBound;
  upperBound?: UpperBound;
}
/**
 * What considerations should be taken into account regarding the model's construction, training, and application?
 */
export interface Considerations {
  users?: Users;
  useCases?: UseCases;
  technicalLimitations?: TechnicalLimitations;
  performanceTradeoffs?: PerformanceTradeoffs;
  ethicalConsiderations?: EthicalConsiderations;
  environmentalConsiderations?: EnvironmentalConsiderations;
  fairnessAssessments?: FairnessAssessments;
}
export interface Risk {
  name?: Name7;
  mitigationStrategy?: MitigationStrategy;
}
/**
 * What are the various environmental impacts the corresponding machine learning model has exhibited across its lifecycle?
 */
export interface EnvironmentalConsiderations {
  energyConsumptions?: EnergyConsumptions;
  properties?: Properties2;
}
/**
 * Describes energy consumption information incurred for the specified lifecycle activity.
 */
export interface EnergyConsumption {
  activity: Activity;
  energyProviders: EnergyProviders;
  activityEnergyCost: ActivityEnergyCost;
  co2CostEquivalent?: CO2EquivalentCost;
  co2CostOffset?: CO2CostOffset;
  properties?: Properties1;
}
/**
 * Describes the physical provider of energy used for model development or operations.
 */
export interface EnergyProvider {
  "bom-ref"?: BOMReference8;
  description?: Description3;
  organization: Organization1;
  energySource: EnergySource;
  energyProvided: EnergyProvided;
  externalReferences?: ExternalReferences1;
}
/**
 * The organization that provides energy.
 */
export interface Organization1 {
  "bom-ref"?: BOMReference1;
  name?: OrganizationName;
  address?: OrganizationAddress;
  url?: OrganizationURLS;
  contact?: OrganizationalContact;
}
/**
 * The energy provided by the energy source for an associated activity.
 */
export interface EnergyProvided {
  value: Value3;
  unit: Unit;
}
/**
 * The total energy cost associated with the model lifecycle activity.
 */
export interface ActivityEnergyCost {
  value: Value3;
  unit: Unit;
}
/**
 * The CO2 cost (debit) equivalent to the total energy cost.
 */
export interface CO2EquivalentCost {
  value: Value4;
  unit: Unit1;
}
/**
 * The CO2 offset (credit) for the CO2 equivalent cost.
 */
export interface CO2CostOffset {
  value: Value4;
  unit: Unit1;
}
/**
 * Information about the benefits and harms of the model to an identified at risk group.
 */
export interface FairnessAssessment {
  groupAtRisk?: GroupAtRisk;
  benefits?: Benefits;
  harms?: Harms;
  mitigationStrategy?: MitigationStrategy1;
}
export interface ComponentData {
  "bom-ref"?: BOMReference7;
  type: TypeOfData;
  name?: DatasetName;
  contents?: DataContents;
  classification?: DataClassification;
  sensitiveData?: SensitiveData;
  graphics?: GraphicsCollection;
  description?: DatasetDescription;
  governance?: DataGovernance;
}
/**
 * Cryptographic assets have properties that uniquely define them and that make them actionable for further reasoning. As an example, it makes a difference if one knows the algorithm family (e.g. AES) or the specific variant or instantiation (e.g. AES-128-GCM). This is because the security level and the algorithm primitive (authenticated encryption) are only defined by the definition of the algorithm variant. The presence of a weak cryptographic algorithm like SHA1 vs. HMAC-SHA1 also makes a difference.
 */
export interface CryptographicProperties {
  assetType: AssetType;
  algorithmProperties?: AlgorithmProperties;
  certificateProperties?: CertificateProperties;
  relatedCryptoMaterialProperties?: RelatedCryptographicMaterialProperties;
  protocolProperties?: ProtocolProperties;
  oid?: OID;
}
/**
 * Additional properties specific to a cryptographic algorithm.
 */
export interface AlgorithmProperties {
  primitive?: Primitive;
  parameterSetIdentifier?: ParameterSetIdentifier;
  curve?: EllipticCurve;
  executionEnvironment?: ExecutionEnvironment;
  implementationPlatform?: ImplementationPlatform;
  certificationLevel?: CertificationLevel;
  mode?: Mode;
  padding?: Padding;
  cryptoFunctions?: CryptographicFunctions;
  classicalSecurityLevel?: ClassicalSecurityLevel;
  nistQuantumSecurityLevel?: NISTSecurityStrengthCategory;
}
/**
 * Properties for cryptographic assets of asset type 'certificate'
 */
export interface CertificateProperties {
  subjectName?: SubjectName;
  issuerName?: IssuerName;
  notValidBefore?: NotValidBefore;
  notValidAfter?: NotValidAfter;
  signatureAlgorithmRef?: AlgorithmReference;
  subjectPublicKeyRef?: KeyReference;
  certificateFormat?: CertificateFormat;
  certificateExtension?: CertificateFileExtension;
}
/**
 * Properties for cryptographic assets of asset type: `related-crypto-material`
 */
export interface RelatedCryptographicMaterialProperties {
  type?: RelatedCryptoMaterialType;
  id?: ID;
  state?: State;
  algorithmRef?: AlgorithmReference1;
  creationDate?: CreationDate;
  activationDate?: ActivationDate;
  updateDate?: UpdateDate;
  expirationDate?: ExpirationDate;
  value?: Value5;
  size?: Size;
  format?: Format;
  securedBy?: SecuredBy;
}
/**
 * The mechanism by which the cryptographic asset is secured by.
 */
export interface SecuredBy {
  mechanism?: Mechanism;
  algorithmRef?: AlgorithmReference2;
}
/**
 * Properties specific to cryptographic assets of type: `protocol`.
 */
export interface ProtocolProperties {
  type?: Type3;
  version?: ProtocolVersion;
  cipherSuites?: CipherSuites;
  ikev2TransformTypes?: IKEv2TransformTypes;
  cryptoRefArray?: CryptographicReferences;
}
/**
 * Object representing a cipher suite
 */
export interface CipherSuite {
  name?: CommonName;
  algorithms?: RelatedAlgorithms;
  identifiers?: CipherSuiteIdentifiers;
}
/**
 * The IKEv2 transform types supported (types 1-4), defined in [RFC 7296 section 3.3.2](https://www.ietf.org/rfc/rfc7296.html#section-3.3.2), and additional properties.
 */
export interface IKEv2TransformTypes {
  encr?: EncryptionAlgorithmENCR;
  prf?: PseudorandomFunctionPRF;
  integ?: IntegrityAlgorithmINTEG;
  ke?: KeyExchangeMethodKE;
  esn?: ExtendedSequenceNumbersESN;
  auth?: IKEv2AuthenticationMethod;
}
export interface Signature2 {
  algorithm: Algorithm | Algorithm1;
  keyId?: KeyID;
  publicKey?: PublicKey;
  certificatePath?: CertificatePath;
  excludes?: Excludes;
  value: Signature3;
}
/**
 * Unique top level property for simple signatures. (signaturecore)
 */
export interface Signature5 {
  algorithm: Algorithm | Algorithm1;
  keyId?: KeyID;
  publicKey?: PublicKey;
  certificatePath?: CertificatePath;
  excludes?: Excludes;
  value: Signature3;
}
export interface Service {
  "bom-ref"?: BOMReference9;
  provider?: Provider;
  group?: ServiceGroup;
  name: ServiceName;
  version?: ServiceVersion;
  description?: ServiceDescription;
  endpoints?: Endpoints;
  authenticated?: AuthenticationRequired;
  "x-trust-boundary"?: CrossesTrustBoundary;
  trustZone?: TrustZone;
  data?: Data1;
  licenses?: ServiceLicenseS;
  externalReferences?: ExternalReferences2;
  services?: Services1;
  releaseNotes?: ReleaseNotes1;
  properties?: Properties5;
  tags?: Tags2;
  signature?: Signature6;
}
/**
 * The organization that provides the service.
 */
export interface Provider {
  "bom-ref"?: BOMReference1;
  name?: OrganizationName;
  address?: OrganizationAddress;
  url?: OrganizationURLS;
  contact?: OrganizationalContact;
}
export interface HashObjects {
  flow: DirectionalFlow;
  classification: DataClassification;
  name?: Name8;
  description?: Description4;
  governance?: DataGovernance1;
  source?: Source1;
  destination?: Destination;
}
/**
 * Data governance captures information regarding data ownership, stewardship, and custodianship, providing insights into the individuals or entities responsible for managing, overseeing, and safeguarding the data throughout its lifecycle.
 */
export interface DataGovernance1 {
  custodians?: DataCustodians;
  stewards?: DataStewards;
  owners?: DataOwners;
}
/**
 * Specifies optional release notes.
 */
export interface ReleaseNotes1 {
  type: Type1;
  title?: Title;
  featuredImage?: FeaturedImage;
  socialImage?: SocialImage;
  description?: Description1;
  timestamp?: Timestamp2;
  aliases?: Aliases;
  tags?: Tags;
  resolves?: Resolves1;
  notes?: Notes1;
  properties?: Properties;
}
/**
 * [Deprecated] This will be removed in a future version. Use component or service instead. Information about the automated or manual tool used
 */
export interface Tool {
  vendor?: ToolVendor;
  name?: ToolName;
  version?: ToolVersion;
  hashes?: Hashes1;
  externalReferences?: ExternalReferences3;
}
/**
 * The organization that created the BOM.
 * Manufacturer is common in BOMs created through automated processes. BOMs created through manual means may have `@.authors` instead.
 */
export interface BOMManufacturer {
  "bom-ref"?: BOMReference1;
  name?: OrganizationName;
  address?: OrganizationAddress;
  url?: OrganizationURLS;
  contact?: OrganizationalContact;
}
/**
 * The component that the BOM describes.
 */
export interface Component1 {
  type: ComponentType;
  "mime-type"?: MimeType;
  "bom-ref"?: BOMReference;
  supplier?: ComponentSupplier;
  manufacturer?: ComponentManufacturer;
  authors?: ComponentAuthors;
  author?: ComponentAuthorLegacy;
  publisher?: ComponentPublisher;
  group?: ComponentGroup;
  name: ComponentName;
  version?: ComponentVersion;
  description?: ComponentDescription;
  scope?: ComponentScope;
  hashes?: ComponentHashes;
  licenses?: ComponentLicenseS;
  copyright?: ComponentCopyright;
  cpe?: CommonPlatformEnumerationCPE;
  purl?: PackageURLPurl;
  omniborId?: OmniBORArtifactIdentifierGitoid;
  swhid?: SoftwareHeritageIdentifier;
  swid?: SWIDTag;
  modified?: ComponentModifiedFromOriginal;
  pedigree?: ComponentPedigree;
  externalReferences?: ExternalReferences;
  components?: Components1;
  evidence?: Evidence;
  releaseNotes?: ReleaseNotes;
  modelCard?: AIMLModelCard;
  data?: Data;
  cryptoProperties?: CryptographicProperties;
  properties?: Properties4;
  tags?: Tags1;
  signature?: Signature;
}
/**
 * @deprecated
 * [Deprecated] This will be removed in a future version. Use the `@.component.manufacturer` instead.
 * The organization that manufactured the component that the BOM describes.
 */
export interface ComponentManufactureLegacy {
  "bom-ref"?: BOMReference1;
  name?: OrganizationName;
  address?: OrganizationAddress;
  url?: OrganizationURLS;
  contact?: OrganizationalContact;
}
/**
 *  The organization that supplied the component that the BOM describes. The supplier may often be the manufacturer, but may also be a distributor or repackager.
 */
export interface Supplier {
  "bom-ref"?: BOMReference1;
  name?: OrganizationName;
  address?: OrganizationAddress;
  url?: OrganizationURLS;
  contact?: OrganizationalContact;
}
/**
 * Defines the direct dependencies of a component, service, or the components provided/implemented by a given component. Components or services that do not have their own dependencies must be declared as empty elements within the graph. Components or services that are not represented in the dependency graph may have unknown dependencies. It is recommended that implementations assume this to be opaque and not an indicator of an object being dependency-free. It is recommended to leverage compositions to indicate unknown dependency graphs.
 */
export interface Dependency {
  ref: Reference1;
  dependsOn?: DependsOn;
  provides?: Provides;
}
export interface Compositions1 {
  "bom-ref"?: BOMReference10;
  aggregate: Aggregate;
  assemblies?: BOMReferences1;
  dependencies?: BOMReferences2;
  vulnerabilities?: BOMReferences3;
  signature?: Signature7;
}
/**
 * Defines a weakness in a component or service that could be exploited or triggered by a threat source.
 */
export interface Vulnerability {
  "bom-ref"?: BOMReference11;
  id?: ID1;
  source?: Source2;
  references?: References1;
  ratings?: Ratings;
  cwes?: CWEs;
  description?: Description5;
  detail?: Details;
  recommendation?: Recommendation;
  workaround?: Workarounds;
  proofOfConcept?: ProofOfConcept;
  advisories?: Advisories;
  created?: Created;
  published?: Published;
  updated?: Updated;
  rejected?: Rejected;
  credits?: Credits;
  tools?: Tools2;
  analysis?: ImpactAnalysis;
  affects?: Affects;
  properties?: Properties7;
}
/**
 * The source that published the vulnerability.
 */
export interface Source2 {
  url?: URL8;
  name?: Name9;
}
/**
 * The source that published the vulnerability.
 */
export interface Source3 {
  url?: URL8;
  name?: Name9;
}
/**
 * Defines the severity or risk ratings of a vulnerability.
 */
export interface Rating {
  source?: Source4;
  score?: Score;
  severity?: Severity;
  method?: Method;
  vector?: Vector;
  justification?: Justification;
}
/**
 * The source that calculated the severity or risk rating of the vulnerability.
 */
export interface Source4 {
  url?: URL8;
  name?: Name9;
}
/**
 * Evidence used to reproduce the vulnerability.
 */
export interface ProofOfConcept {
  reproductionSteps?: StepsToReproduce;
  environment?: Environment;
  supportingMaterial?: SupportingMaterial;
  [k: string]: unknown;
}
/**
 * Specifies the metadata and content for an attachment.
 */
export interface Attachment {
  contentType?: ContentType;
  encoding?: Encoding;
  content: AttachmentText1;
}
/**
 * Title and location where advisory information can be obtained. An advisory is a notification of a threat to a component, service, or system.
 */
export interface Advisory {
  title?: Title1;
  url: URL9;
}
/**
 * Individuals or organizations credited with the discovery of the vulnerability.
 */
export interface Credits {
  organizations?: Organizations;
  individuals?: Individuals;
}
export interface OrganizationalEntity {
  "bom-ref"?: BOMReference1;
  name?: OrganizationName;
  address?: OrganizationAddress;
  url?: OrganizationURLS;
  contact?: OrganizationalContact;
}
/**
 * The tool(s) used to identify, confirm, or score the vulnerability.
 */
export interface Tools3 {
  components?: Components3;
  services?: Services3;
}
/**
 * An assessment of the impact and exploitability of the vulnerability.
 */
export interface ImpactAnalysis {
  state?: ImpactAnalysisState;
  justification?: ImpactAnalysisJustification;
  response?: Response;
  detail?: Detail;
  firstIssued?: FirstIssued;
  lastUpdated?: LastUpdated;
}
/**
 * A comment, note, explanation, or similar textual content which provides additional context to the object(s) being annotated.
 */
export interface Annotations1 {
  "bom-ref"?: BOMReference12;
  subjects: Subjects;
  annotator: Annotator;
  timestamp: Timestamp3;
  text: Text;
  signature?: Signature8;
}
/**
 * Describes workflows and resources that captures rules and other aspects of how the associated BOM component or service was formed.
 */
export interface Formula {
  "bom-ref"?: BOMReference13;
  components?: Components4;
  services?: Services4;
  workflows?: Workflows;
  properties?: Properties18;
}
/**
 * A specialized orchestration task.
 */
export interface Workflow {
  "bom-ref": BOMReference14;
  uid: UniqueIdentifierUID;
  name?: Name10;
  description?: Description6;
  resourceReferences?: ResourceReferences;
  tasks?: Tasks;
  taskDependencies?: TaskDependencyGraph;
  taskTypes: TaskTypes1;
  trigger?: Trigger1;
  steps?: Steps1;
  inputs?: Inputs3;
  outputs?: Outputs3;
  timeStart?: TimeStart1;
  timeEnd?: TimeEnd1;
  workspaces?: Workspaces1;
  runtimeTopology?: RuntimeTopology1;
  properties?: Properties17;
}
/**
 * Describes the inputs, sequence of steps and resources used to accomplish a task and its output.
 */
export interface Task1 {
  "bom-ref": BOMReference15;
  uid: UniqueIdentifierUID1;
  name?: Name11;
  description?: Description7;
  resourceReferences?: ResourceReferences1;
  taskTypes: TaskTypes;
  trigger?: Trigger;
  steps?: Steps;
  inputs?: Inputs2;
  outputs?: Outputs2;
  timeStart?: TimeStart;
  timeEnd?: TimeEnd;
  workspaces?: Workspaces;
  runtimeTopology?: RuntimeTopology;
  properties?: Properties16;
}
/**
 * The trigger that initiated the task.
 */
export interface Trigger {
  "bom-ref": BOMReference16;
  uid: UniqueIdentifierUID2;
  name?: Name12;
  description?: Description8;
  resourceReferences?: ResourceReferences2;
  type: Type4;
  event?: Event;
  conditions?: Conditions;
  timeActivated?: TimeActivated;
  inputs?: Inputs1;
  outputs?: Outputs1;
  properties?: Properties11;
}
/**
 * The event data that caused the associated trigger to activate.
 */
export interface Event {
  uid?: UniqueIdentifierUID3;
  description?: Description9;
  timeReceived?: TimeReceived;
  data?: Attachment1;
  source?: ResourceReferenceChoice1;
  target?: ResourceReferenceChoice2;
  properties?: Properties8;
}
/**
 * Specifies the metadata and content for an attachment.
 */
export interface Attachment1 {
  contentType?: ContentType;
  encoding?: Encoding;
  content: AttachmentText1;
}
/**
 * A condition that was used to determine a trigger should be activated.
 */
export interface Condition {
  description?: Description10;
  expression?: Expression;
  properties?: Properties9;
}
/**
 * Specifies the metadata and content for an attachment.
 */
export interface Attachment2 {
  contentType?: ContentType;
  encoding?: Encoding;
  content: AttachmentText1;
}
/**
 * Executes specific commands or tools in order to accomplish its owning task as part of a sequence.
 */
export interface Step {
  name?: Name13;
  description?: Description11;
  commands?: Commands;
  properties?: Properties13;
}
export interface Command {
  executed?: Executed;
  properties?: Properties12;
}
/**
 * A named filesystem or data resource shareable by workflow tasks.
 */
export interface Workspace {
  "bom-ref": BOMReference17;
  uid: UniqueIdentifierUID4;
  name?: Name14;
  aliases?: Aliases1;
  description?: Description12;
  resourceReferences?: ResourceReferences3;
  accessMode?: AccessMode;
  mountPath?: MountPath;
  managedDataType?: ManagedDataType;
  volumeRequest?: VolumeRequest;
  volume?: Volume;
  properties?: Properties15;
}
/**
 * Information about the actual volume instance allocated to the workspace.
 */
export interface Volume {
  uid?: UniqueIdentifierUID5;
  name?: Name15;
  mode?: Mode1;
  path?: Path;
  sizeAllocated?: SizeAllocated;
  persistent?: Persistent;
  remote?: Remote;
  properties?: Properties14;
}
/**
 * The trigger that initiated the task.
 */
export interface Trigger1 {
  "bom-ref": BOMReference16;
  uid: UniqueIdentifierUID2;
  name?: Name12;
  description?: Description8;
  resourceReferences?: ResourceReferences2;
  type: Type4;
  event?: Event;
  conditions?: Conditions;
  timeActivated?: TimeActivated;
  inputs?: Inputs1;
  outputs?: Outputs1;
  properties?: Properties11;
}
/**
 * The list of declarations which describe the conformance to standards. Each declaration may include attestations, claims, and evidence.
 */
export interface Declarations {
  assessors?: Assessors;
  attestations?: Attestations;
  claims?: Claims1;
  evidence?: Evidence2;
  targets?: Targets;
  affirmation?: Affirmation;
  signature?: Signature13;
}
/**
 * The assessor who evaluates claims and determines conformance to requirements and confidence in that assessment.
 */
export interface Assessor {
  "bom-ref"?: BOMReference18;
  thirdParty?: ThirdParty;
  organization?: OrganizationalEntity1;
}
/**
 * The entity issuing the assessment.
 */
export interface OrganizationalEntity1 {
  "bom-ref"?: BOMReference1;
  name?: OrganizationName;
  address?: OrganizationAddress;
  url?: OrganizationURLS;
  contact?: OrganizationalContact;
}
export interface Attestation {
  summary?: Summary;
  assessor?: Assessor1;
  map?: Map;
  signature?: Signature9;
}
export interface Map1 {
  requirement?: Requirement;
  claims?: Claims;
  counterClaims?: CounterClaims;
  conformance?: Conformance;
  confidence?: Confidence2;
}
/**
 * The conformance of the claim meeting a requirement.
 */
export interface Conformance {
  score?: Score1;
  rationale?: Rationale;
  mitigationStrategies?: MitigationStrategies;
}
/**
 * The confidence of the claim meeting the requirement.
 */
export interface Confidence2 {
  score?: Score2;
  rationale?: Rationale1;
}
export interface Claim {
  "bom-ref"?: BOMReference19;
  target?: Target;
  predicate?: Predicate;
  mitigationStrategies?: MitigationStrategies1;
  reasoning?: Reasoning;
  evidence?: Evidence1;
  counterEvidence?: CounterEvidence;
  externalReferences?: ExternalReferences5;
  signature?: Signature10;
}
export interface Evidence3 {
  "bom-ref"?: BOMReference20;
  propertyName?: PropertyName;
  description?: Description13;
  data?: Data2;
  created?: Created1;
  expires?: Expires;
  author?: OrganizationalContact3;
  reviewer?: OrganizationalContact4;
  signature?: Signature11;
}
export interface Data3 {
  name?: DataName;
  contents?: DataContents1;
  classification?: DataClassification;
  sensitiveData?: SensitiveData1;
  governance?: DataGovernance2;
}
/**
 * The contents or references to the contents of the data being described.
 */
export interface DataContents1 {
  attachment?: Attachment3;
  url?: DataURL1;
}
/**
 * Specifies the metadata and content for an attachment.
 */
export interface Attachment3 {
  contentType?: ContentType;
  encoding?: Encoding;
  content: AttachmentText1;
}
/**
 * Data governance captures information regarding data ownership, stewardship, and custodianship, providing insights into the individuals or entities responsible for managing, overseeing, and safeguarding the data throughout its lifecycle.
 */
export interface DataGovernance2 {
  custodians?: DataCustodians;
  stewards?: DataStewards;
  owners?: DataOwners;
}
/**
 * The author of the evidence.
 */
export interface OrganizationalContact3 {
  "bom-ref"?: BOMReference3;
  name?: Name1;
  email?: EmailAddress;
  phone?: Phone;
}
/**
 * The reviewer of the evidence.
 */
export interface OrganizationalContact4 {
  "bom-ref"?: BOMReference3;
  name?: Name1;
  email?: EmailAddress;
  phone?: Phone;
}
/**
 * The list of targets which claims are made against.
 */
export interface Targets {
  organizations?: Organizations1;
  components?: Components5;
  services?: Services5;
}
/**
 * A concise statement affirmed by an individual regarding all declarations, often used for third-party auditor acceptance or recipient acknowledgment. It includes a list of authorized signatories who assert the validity of the document on behalf of the organization.
 */
export interface Affirmation {
  statement?: Statement;
  signatories?: Signatories;
  signature?: Signature12;
}
/**
 * A collection of reusable objects that are defined and may be used elsewhere in the BOM.
 */
export interface Definitions {
  standards?: Standards;
}
/**
 * A standard may consist of regulations, industry or organizational-specific standards, maturity models, best practices, or any other requirements which can be evaluated against or attested to.
 */
export interface Standard {
  "bom-ref"?: BOMReference21;
  name?: Name16;
  version?: Version1;
  description?: Description14;
  owner?: Owner;
  requirements?: Requirements;
  levels?: Levels;
  externalReferences?: ExternalReferences7;
  signature?: Signature14;
}
export interface Requirement1 {
  "bom-ref"?: BOMReference22;
  identifier?: Identifier1;
  title?: Title2;
  text?: Text1;
  descriptions?: Descriptions;
  openCre?: OWASPOpenCREIdentifierS;
  parent?: ParentBOMReference;
  properties?: Properties19;
  externalReferences?: ExternalReferences6;
}
export interface Level {
  "bom-ref"?: BOMReference23;
  identifier?: Identifier2;
  title?: Title3;
  description?: Description15;
  requirements?: Requirements1;
}
